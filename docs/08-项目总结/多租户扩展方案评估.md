# 多租户扩展方案评估

## 一、改造难度评估

### 结论：**改造难度：中等（3-5天工作量）**

如果先按单一企业架构调整，后续再扩展为多租户，改造难度是**可控的**，主要原因：

1. ✅ **数据模型改动小**：只需添加 tenant_id 字段
2. ✅ **Casbin 模型类似**：只是把 org_id 换成 tenant_id
3. ✅ **代码结构清晰**：分层架构便于修改
4. ⚠️ **需要数据迁移**：现有数据需要分配 tenant_id
5. ⚠️ **需要重新配置权限**：Casbin 策略需要重新初始化

---

## 二、两种架构对比

### 方案A：当前多租户方案（基于 org_id）

```
问题：
- org_id 既用于组织架构，又用于租户隔离
- 子组织无法继承父组织角色
- 概念混淆：组织 ≠ 租户
```

### 方案B：单一企业方案（去除租户概念）

```
优势：
- 简单清晰，符合单一企业场景
- 角色全局生效
- org_id 只用于组织架构

劣势：
- 如果后续需要多租户，需要改造
```

### 方案C：多租户方案（基于 tenant_id）✅ 推荐

```
优势：
- 概念清晰：tenant_id（租户隔离）+ org_id（组织架构）
- 租户内的组织可以共享角色
- 易于扩展为 SaaS 产品

实现：
- 每个租户有独立的角色权限体系
- 租户内的所有组织共享角色
- org_id 只用于数据权限范围控制
```

---

## 三、推荐方案：预留多租户扩展能力

### 核心思路

**现在**：按单一企业实现，但预留多租户扩展点
**未来**：需要多租户时，只需激活扩展点

### 3.1 数据模型设计（预留扩展）

#### 用户表
```sql
CREATE TABLE s_user (
    id BIGINT PRIMARY KEY,
    tenant_id BIGINT DEFAULT 1,              -- 租户ID（预留，默认1）
    org_id BIGINT NOT NULL,                  -- 组织ID（部门归属）
    user_name VARCHAR(100) UNIQUE NOT NULL,
    -- ... 其他字段
);

CREATE INDEX idx_user_tenant ON s_user(tenant_id);
CREATE INDEX idx_user_org ON s_user(org_id);
```

#### 角色表
```sql
CREATE TABLE s_role (
    id BIGINT PRIMARY KEY,
    tenant_id BIGINT DEFAULT 1,              -- 租户ID（预留，默认1）
    role_key VARCHAR(100) NOT NULL,
    role_name VARCHAR(100) NOT NULL,
    -- ... 其他字段
    UNIQUE(tenant_id, role_key)              -- 租户内角色标识唯一
);

CREATE INDEX idx_role_tenant ON s_role(tenant_id);
```

#### 组织表
```sql
CREATE TABLE s_org (
    id BIGINT PRIMARY KEY,
    tenant_id BIGINT DEFAULT 1,              -- 租户ID（预留，默认1）
    parent_id BIGINT DEFAULT 0,
    ancestors VARCHAR(500),
    org_name VARCHAR(100) NOT NULL,
    -- ... 其他字段
);

CREATE INDEX idx_org_tenant ON s_org(tenant_id);
```

#### 租户表（预留）
```sql
CREATE TABLE s_tenant (
    id BIGINT PRIMARY KEY,
    tenant_code VARCHAR(50) UNIQUE NOT NULL,  -- 租户编码
    tenant_name VARCHAR(100) NOT NULL,        -- 租户名称
    status INTEGER DEFAULT 0,                 -- 状态：0正常 1停用
    expire_time TIMESTAMP,                    -- 过期时间
    max_users INTEGER DEFAULT 100,            -- 最大用户数
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 初始化默认租户
INSERT INTO s_tenant (id, tenant_code, tenant_name) 
VALUES (1, 'default', '默认租户');
```

### 3.2 Casbin 模型（支持开关）

#### 配置文件：`cmd/api/casbin_model.conf`

```ini
# Casbin RBAC 模型配置文件
# 支持单一企业和多租户两种模式

# 模式配置（通过环境变量或配置文件控制）
# MULTI_TENANT_MODE=false  单一企业模式
# MULTI_TENANT_MODE=true   多租户模式

[request_definition]
# 单一企业模式: r = sub, obj, act
# 多租户模式:   r = sub, dom, obj, act
r = sub, obj, act

[policy_definition]
# 单一企业模式: p = sub, obj, act
# 多租户模式:   p = sub, dom, obj, act
p = sub, obj, act

[role_definition]
# 单一企业模式: g = _, _
# 多租户模式:   g = _, _, _
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
# 单一企业模式
m = g(r.sub, p.sub) && keyMatch2(r.obj, p.obj) && keyMatch2(r.act, p.act) || p.sub == "role::super_admin" && g(r.sub, p.sub)

# 多租户模式（注释掉，需要时启用）
# m = g(r.sub, p.sub, r.dom) && r.dom == p.dom && keyMatch2(r.obj, p.obj) && keyMatch2(r.act, p.act) || p.sub == "role::super_admin" && g(r.sub, p.sub, r.dom) && r.dom == p.dom
```

### 3.3 代码设计（支持开关）

#### 配置文件：`internal/config/config.go`

```go
type Config struct {
    // ... 其他配置
    
    // 多租户配置
    MultiTenant MultiTenantConfig `yaml:"multi_tenant"`
}

type MultiTenantConfig struct {
    Enabled bool `yaml:"enabled" default:"false"`  // 是否启用多租户
}
```

#### CasbinService 接口（兼容两种模式）

```go
// internal/service/casbin.go

type CasbinService interface {
    // 权限检查（自动适配单租户/多租户）
    CheckPermission(ctx context.Context, userId int64, resource, action string) (bool, error)
    
    // 角色管理（自动适配）
    AddRoleForUser(ctx context.Context, userId int64, roleKey string) error
    DeleteRoleForUser(ctx context.Context, userId int64, roleKey string) error
    GetRolesForUser(ctx context.Context, userId int64) ([]string, error)
    
    // 权限管理（自动适配）
    AddPermissionForRole(ctx context.Context, roleKey string, resource, action string) error
    DeletePermissionForRole(ctx context.Context, roleKey string, resource, action string) error
    GetPermissionsForRole(ctx context.Context, roleKey string) ([][]string, error)
}

type casbinService struct {
    enforcer       *casbin.Enforcer
    db             *gorm.DB
    logger         logger.Logger
    multiTenantEnabled bool  // 多租户开关
}

// CheckPermission 自动适配单租户/多租户
func (s *casbinService) CheckPermission(ctx context.Context, userId int64, resource, action string) (bool, error) {
    sub := fmt.Sprintf("user::%d", userId)
    
    if s.multiTenantEnabled {
        // 多租户模式：从 context 获取 tenantId
        tenantId := ctx.Value("tenantId").(int64)
        dom := fmt.Sprintf("tenant::%d", tenantId)
        return s.enforcer.Enforce(sub, dom, resource, action)
    } else {
        // 单一企业模式
        return s.enforcer.Enforce(sub, resource, action)
    }
}

// AddRoleForUser 自动适配单租户/多租户
func (s *casbinService) AddRoleForUser(ctx context.Context, userId int64, roleKey string) error {
    sub := fmt.Sprintf("user::%d", userId)
    role := fmt.Sprintf("role::%s", roleKey)
    
    if s.multiTenantEnabled {
        // 多租户模式
        tenantId := ctx.Value("tenantId").(int64)
        dom := fmt.Sprintf("tenant::%d", tenantId)
        _, err := s.enforcer.AddGroupingPolicy(sub, role, dom)
        return err
    } else {
        // 单一企业模式
        _, err := s.enforcer.AddGroupingPolicy(sub, role)
        return err
    }
}
```

#### Auth 中间件（自动提取 tenantId）

```go
// internal/middleware/auth.go

func Auth(tokenManager service.TokenManager, cfg *config.Config, db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 验证 Token
        token := c.GetHeader("Authorization")
        claims, err := tokenManager.ValidateAccessToken(c.Request.Context(), token)
        if err != nil {
            response.Unauthorized(c, "Token无效")
            c.Abort()
            return
        }
        
        // 2. 查询用户信息
        var user model.User
        if err := db.Where("id = ?", claims.UserId).First(&user).Error; err != nil {
            response.Unauthorized(c, "用户不存在")
            c.Abort()
            return
        }
        
        // 3. 设置用户信息到 context
        c.Set("userId", user.ID)
        c.Set("orgId", user.OrgId)
        
        // 4. 如果启用多租户，设置 tenantId
        if cfg.MultiTenant.Enabled {
            c.Set("tenantId", user.TenantId)
        }
        
        c.Next()
    }
}
```

---

## 四、扩展为多租户的步骤

### 步骤1：数据准备（1天）

```sql
-- 1. 创建租户表
CREATE TABLE s_tenant (...);

-- 2. 为现有表添加 tenant_id 字段
ALTER TABLE s_user ADD COLUMN tenant_id BIGINT DEFAULT 1;
ALTER TABLE s_role ADD COLUMN tenant_id BIGINT DEFAULT 1;
ALTER TABLE s_org ADD COLUMN tenant_id BIGINT DEFAULT 1;
ALTER TABLE s_menu ADD COLUMN tenant_id BIGINT DEFAULT 1;

-- 3. 添加索引
CREATE INDEX idx_user_tenant ON s_user(tenant_id);
CREATE INDEX idx_role_tenant ON s_role(tenant_id);
CREATE INDEX idx_org_tenant ON s_org(tenant_id);

-- 4. 更新唯一约束
ALTER TABLE s_role DROP CONSTRAINT s_role_role_key_key;
ALTER TABLE s_role ADD CONSTRAINT s_role_tenant_key UNIQUE(tenant_id, role_key);
```

### 步骤2：修改配置（0.5天）

```yaml
# conf.dev.yaml
multi_tenant:
  enabled: true  # 启用多租户
```

```ini
# cmd/api/casbin_model.conf
# 切换到多租户模式
[request_definition]
r = sub, dom, obj, act

[policy_definition]
p = sub, dom, obj, act

[role_definition]
g = _, _, _

[matchers]
m = g(r.sub, p.sub, r.dom) && r.dom == p.dom && keyMatch2(r.obj, p.obj) && keyMatch2(r.act, p.act)
```

### 步骤3：代码调整（2天）

主要修改点：
1. `CasbinService` 实现中的 `multiTenantEnabled` 判断逻辑
2. `Auth` 中间件提取 `tenantId`
3. `Service` 层查询时添加 `tenant_id` 过滤
4. `Controller` 层接口调整

### 步骤4：数据迁移（0.5天）

```sql
-- 清空 Casbin 策略
TRUNCATE TABLE casbin_rule;

-- 重新初始化租户1的权限
-- 通过代码或脚本执行
```

### 步骤5：测试验证（1天）

- 创建新租户
- 测试租户隔离
- 测试权限检查
- 测试数据隔离

---

## 五、改造成本对比

### 方案A：现在就实现多租户（基于 tenant_id）

**工作量**：5-7天
- 数据模型设计：1天
- Casbin 模型调整：1天
- 代码实现：3-4天
- 测试验证：1天

**优势**：
- 一步到位，架构清晰
- 避免二次改造

**劣势**：
- 当前不需要，过度设计
- 增加系统复杂度
- 维护成本高

### 方案B：先单一企业，需要时再改造

**工作量**：
- 现在：2-3天（单一企业）
- 未来：3-5天（扩展多租户）
- 总计：5-8天

**优势**：
- 当前简单，易于维护
- 按需扩展，避免浪费
- 可以根据实际需求调整

**劣势**：
- 需要二次改造
- 有数据迁移成本

### 方案C：预留扩展能力（推荐）✅

**工作量**：
- 现在：3-4天（单一企业 + 预留扩展点）
- 未来：2-3天（激活多租户）
- 总计：5-7天

**优势**：
- 当前简单，未来易扩展
- 改造成本最低
- 架构清晰，概念分离

**劣势**：
- 需要提前规划

---

## 六、推荐实施方案

### 阶段1：当前实施（3-4天）

1. **数据模型**：添加 `tenant_id` 字段（默认值1）
2. **代码实现**：按单一企业实现，但预留 `multiTenantEnabled` 开关
3. **配置文件**：`multi_tenant.enabled = false`
4. **Casbin 模型**：使用单一企业模式

### 阶段2：未来扩展（2-3天）

1. **创建租户表**：`s_tenant`
2. **修改配置**：`multi_tenant.enabled = true`
3. **切换 Casbin 模型**：启用多租户模式
4. **数据迁移**：分配 `tenant_id`
5. **测试验证**

---

## 七、关键代码示例

### 自动适配的 Service 层

```go
// internal/service/user.go

func (s *UserService) List(ctx context.Context, currentUserId int64) ([]User, error) {
    query := s.db.Model(&User{})
    
    // 如果启用多租户，自动添加租户过滤
    if s.config.MultiTenant.Enabled {
        tenantId := ctx.Value("tenantId").(int64)
        query = query.Where("tenant_id = ?", tenantId)
    }
    
    // 数据权限控制（基于 data_scope）
    currentUser, _ := s.GetById(ctx, currentUserId)
    roles, _ := s.roleService.GetUserRoles(ctx, currentUserId)
    
    maxDataScope := s.getMaxDataScope(roles)
    switch maxDataScope {
    case DataScopeAll:
        // 全部数据（租户内）
    case DataScopeOrg:
        query = query.Where("org_id = ?", currentUser.OrgId)
    case DataScopeOrgBelow:
        query = query.Where("org_id IN (?)", s.getOrgTree(currentUser.OrgId))
    case DataScopeSelf:
        query = query.Where("id = ?", currentUserId)
    }
    
    var users []User
    err := query.Find(&users).Error
    return users, err
}
```

---

## 八、总结

### 改造难度评估

| 方案 | 当前工作量 | 未来工作量 | 总工作量 | 推荐度 |
|------|-----------|-----------|---------|--------|
| 现在就多租户 | 5-7天 | 0天 | 5-7天 | ⭐⭐⭐ |
| 先单一后改造 | 2-3天 | 3-5天 | 5-8天 | ⭐⭐⭐⭐ |
| 预留扩展能力 | 3-4天 | 2-3天 | 5-7天 | ⭐⭐⭐⭐⭐ |

### 最终建议

**推荐方案C：预留扩展能力**

**理由**：
1. ✅ 当前按单一企业实现，简单清晰
2. ✅ 数据模型预留 `tenant_id` 字段
3. ✅ 代码预留 `multiTenantEnabled` 开关
4. ✅ 未来扩展成本低（2-3天）
5. ✅ 概念清晰：`tenant_id`（租户）+ `org_id`（组织）

**实施步骤**：
1. 现在：按单一企业实现，但数据模型和代码预留扩展点
2. 未来：需要多租户时，修改配置文件即可激活

这样既满足当前需求，又为未来扩展留有余地，是最优方案。
