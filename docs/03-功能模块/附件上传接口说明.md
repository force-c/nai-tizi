# 附件上传接口说明

## 概述

附件上传接口采用分两步上传的方式，符合"参数 > 3 个时使用 JSON Body"的规范。

**实现方式：** 分两步上传（步骤1：2个参数，步骤2：6个参数使用JSON）

---

## 接口说明

### 步骤 1：上传文件
```http
POST /api/v1/attachments/upload-file
Content-Type: multipart/form-data

file: [binary]
envCode: default
```

**响应：**
```json
{
  "code": 200,
  "message": "上传文件成功",
  "data": {
    "attachmentId": 123,
    "fileName": "document.pdf",
    "fileSize": 1024000,
    "fileExt": "pdf",
    "envId": 1
  }
}
```

### 步骤 2：绑定业务信息
```http
POST /api/v1/attachments/123/bind
Content-Type: application/json

{
  "businessType": "order",
  "businessId": "123",
  "businessField": "invoice",
  "isPublic": true,
  "metadata": {
    "key": "value",
    "orderId": 123
  },
  "expireTime": "2024-12-31T23:59:59Z"
}
```

**响应：**
```json
{
  "code": 200,
  "message": "绑定附件到业务成功"
}
```

**优点：**
- ✅ 符合参数传递规范（步骤1：2个参数，步骤2：JSON Body）
- ✅ 职责清晰（上传和绑定分离）
- ✅ metadata 使用 JSON 对象，无需手动序列化
- ✅ 易于扩展和维护
- ✅ 支持先上传后绑定的场景

---

## 使用示例

### 前端代码

```javascript
// 步骤1：上传文件
async function uploadFile(file, envCode = '') {
  const formData = new FormData();
  formData.append('file', file);
  if (envCode) {
    formData.append('envCode', envCode);
  }
  
  const response = await fetch('/api/v1/attachments/upload-file', {
    method: 'POST',
    body: formData
  });
  
  return response.json();
}

// 步骤2：绑定业务信息
async function bindAttachment(attachmentId, businessInfo) {
  const response = await fetch(`/api/v1/attachments/${attachmentId}/bind`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      businessType: businessInfo.businessType,
      businessId: businessInfo.businessId,
      businessField: businessInfo.businessField || '',
      isPublic: businessInfo.isPublic || false,
      metadata: businessInfo.metadata || {}, // 直接传递对象
      expireTime: businessInfo.expireTime || null
    })
  });
  
  return response.json();
}

// 完整流程
async function uploadAttachmentWithBusiness(file, businessInfo) {
  try {
    // 步骤1：上传文件
    const uploadResult = await uploadFile(file, businessInfo.envCode);
    if (uploadResult.code !== 200) {
      throw new Error(uploadResult.message);
    }
    
    const attachmentId = uploadResult.data.attachmentId;
    
    // 步骤2：绑定业务信息
    const bindResult = await bindAttachment(attachmentId, businessInfo);
    if (bindResult.code !== 200) {
      throw new Error(bindResult.message);
    }
    
    return {
      attachmentId,
      fileName: uploadResult.data.fileName,
      fileSize: uploadResult.data.fileSize
    };
  } catch (error) {
    console.error('上传失败:', error);
    throw error;
  }
}
```

---

## 使用场景

### 场景 1：立即绑定业务信息
```javascript
// 用户上传订单发票
const file = document.getElementById('fileInput').files[0];
const result = await uploadAttachmentWithBusiness(file, {
  envCode: 'default',
  businessType: 'order',
  businessId: '12345',
  businessField: 'invoice',
  isPublic: false,
  metadata: {
    orderId: 12345,
    orderNo: 'ORD-2024-001'
  }
});

console.log('附件ID:', result.attachmentId);
```

### 场景 2：先上传，稍后绑定
```javascript
// 用户先上传文件，在表单提交时再绑定
// 步骤1：用户选择文件后立即上传
const file = document.getElementById('fileInput').files[0];
const uploadResult = await uploadFile(file);
const attachmentId = uploadResult.data.attachmentId;

// 保存 attachmentId 到表单
document.getElementById('attachmentId').value = attachmentId;

// 步骤2：用户填写完表单后，提交时绑定业务信息
async function submitForm() {
  const attachmentId = document.getElementById('attachmentId').value;
  const orderId = document.getElementById('orderId').value;
  
  await bindAttachment(attachmentId, {
    businessType: 'order',
    businessId: orderId,
    businessField: 'invoice',
    isPublic: false
  });
  
  // 提交表单...
}
```

### 场景 3：批量上传
```javascript
// 批量上传多个文件
async function uploadMultipleFiles(files, businessInfo) {
  const results = [];
  
  for (const file of files) {
    try {
      // 步骤1：上传文件
      const uploadResult = await uploadFile(file, businessInfo.envCode);
      const attachmentId = uploadResult.data.attachmentId;
      
      // 步骤2：绑定业务信息
      await bindAttachment(attachmentId, businessInfo);
      
      results.push({
        success: true,
        attachmentId,
        fileName: uploadResult.data.fileName
      });
    } catch (error) {
      results.push({
        success: false,
        fileName: file.name,
        error: error.message
      });
    }
  }
  
  return results;
}
```

---

## 常见问题

### Q1：为什么要分两步上传？

**A：** 主要原因：
1. **符合规范** - 参数 > 3 个时应使用 JSON Body
2. **职责清晰** - 文件上传和业务绑定分离
3. **灵活性** - 支持先上传后绑定的场景
4. **易于维护** - 参数校验和文档生成更简单

### Q2：分两步会不会影响性能？

**A：** 影响很小：
- 文件上传是主要耗时操作，业务信息绑定只是数据库更新
- 两次请求的网络开销相比文件上传可以忽略
- 可以通过并发优化（如批量绑定）来提升性能

### Q3：如果上传成功但绑定失败怎么办？

**A：** 有以下处理方式：
1. **前端重试** - 捕获绑定失败，提示用户重试
2. **定时清理** - 后端定时清理未绑定的附件
3. **手动绑定** - 提供管理界面手动绑定附件

### Q4：metadata 字段有什么特点？

**A：** 
- metadata 是 JSON 对象，自动序列化
- 支持任意结构的元数据
- 更方便、更安全、支持类型校验

---

## 技术细节

### Request 结构体

#### UploadFileRequest（步骤1）
```go
type UploadFileRequest struct {
    File    *multipart.FileHeader `form:"file" binding:"required"`
    EnvCode string                `form:"envCode"` // 可选
}
```

#### BindAttachmentToBusinessRequest（步骤2）
```go
type BindAttachmentToBusinessRequest struct {
    BusinessType  string                 `json:"businessType" binding:"required"`
    BusinessId    string                 `json:"businessId" binding:"required"`
    BusinessField string                 `json:"businessField"`
    IsPublic      bool                   `json:"isPublic"`
    Metadata      map[string]interface{} `json:"metadata"`
    ExpireTime    *time.Time             `json:"expireTime"`
}
```

### Service 方法

```go
// 步骤1：上传文件
func (s *AttachmentService) UploadFile(ctx context.Context, req *request.UploadFileRequest) (*model.Attachment, error)

// 步骤2：绑定业务信息
func (s *AttachmentService) BindToBusiness(ctx context.Context, attachmentId int64, req *request.BindAttachmentToBusinessRequest) error
```

---

## 相关文档

- [参数传递规范](../01-规范/参数传递规范.md) - 参数传递的核心规范
- [参数校验优化规范](../01-规范/参数校验优化规范.md) - 参数校验的详细说明
- [存储环境管理指南](./存储环境管理指南.md) - 存储环境配置说明

---

**更新时间：** 2024-12-20  
**适用版本：** v1.1.0+
