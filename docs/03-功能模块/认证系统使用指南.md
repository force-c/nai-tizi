# 认证系统使用指南

## 概述

本系统采用标准 OAuth2 客户端认证模式，支持多种登录方式、Token 过期策略和并发登录控制。

## 核心特性

1. **客户端认证**: clientKey + clientSecret 双重验证
2. **多种登录方式**: 密码登录、短信验证码登录、邮箱验证码登录、微信小程序登录
3. **双重超时机制**:
   - **Timeout**: 固定超时时间（默认 7 天）
   - **ActiveTimeout**: 活动超时时间（默认 30 分钟）
4. **并发登录控制**: 支持允许/禁止并发登录
5. **共享 Token**: 并发登录时可选择共享或独立 Token

## 配置说明

### 配置文件 (conf.dev.yaml)

```yaml
# 认证配置
auth:
  tokenHeader: "Authorization"  # Token 请求头名称，默认 "Authorization"
  allowConcurrent: false         # 是否允许同一用户并发登录，默认 false
  shareToken: false              # 并发登录时是否共享 Token，默认 false
```

### 配置项说明

| 配置项 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `tokenHeader` | string | "Authorization" | Token 请求头名称 |
| `allowConcurrent` | bool | false | 是否允许同一用户并发登录 |
| `shareToken` | bool | false | 并发登录时是否共享 Token（仅在 allowConcurrent=true 时生效） |

### 并发登录策略

| allowConcurrent | shareToken | 行为 |
|-----------------|------------|------|
| false | - | 新登录会使旧 Token 失效（单设备登录） |
| true | false | 允许多设备登录，每次登录生成新 Token |
| true | true | 允许多设备登录，所有设备共用同一个 Token |

## 客户端配置 (SysClient)

### 数据库表结构

```sql
CREATE TABLE sys_client (
    client_id VARCHAR(64) PRIMARY KEY,      -- 客户端ID (MD5(clientKey + clientSecret))
    client_key VARCHAR(32) UNIQUE NOT NULL, -- 客户端Key
    client_secret VARCHAR(255) NOT NULL,    -- 客户端密钥
    grant_type VARCHAR(255),                -- 授权类型(逗号分隔): password,sms,email,xcx
    device_type VARCHAR(32),                -- 设备类型: pc,ios,android,xcx
    status INT DEFAULT 0,                   -- 状态: 0正常 1停用
    timeout BIGINT DEFAULT 604800,          -- 固定超时时间(秒)，默认7天
    active_timeout BIGINT DEFAULT 1800,     -- 活动超时时间(秒)，默认30分钟
    create_time TIMESTAMP,
    update_time TIMESTAMP,
    remark VARCHAR(500)
);
```

### 字段说明

- **clientKey**: 客户端唯一标识，如 `web-admin`, `mobile-ios`
- **clientSecret**: 客户端密钥，用于验证客户端身份
- **clientId**: 由 `MD5(clientKey + clientSecret)` 自动生成
- **grantType**: 支持的授权类型，逗号分隔，如 `password,sms,email`
- **deviceType**: 设备类型，存入 Token 供业务使用
- **timeout**: Token 的绝对过期时间（秒）
- **activeTimeout**: Token 的活动超时时间（秒），超过此时间无操作则过期

### 示例配置

```sql
-- Web 管理后台
INSERT INTO sys_client (client_key, client_secret, grant_type, device_type, timeout, active_timeout, remark)
VALUES ('web-admin', 'web-secret-xxx', 'password', 'pc', 604800, 1800, 'Web管理后台');

-- 移动 App (iOS)
INSERT INTO sys_client (client_key, client_secret, grant_type, device_type, timeout, active_timeout, remark)
VALUES ('mobile-ios', 'ios-secret-xxx', 'password,sms', 'ios', 2592000, 3600, 'iOS移动应用');

-- 微信小程序
INSERT INTO sys_client (client_key, client_secret, grant_type, device_type, timeout, active_timeout, remark)
VALUES ('wechat-xcx', 'xcx-secret-xxx', 'xcx', 'xcx', 7776000, 7200, '微信小程序');
```

## API 使用示例

### 1. 密码登录

```bash
POST /login
Content-Type: application/json

{
  "clientKey": "web-admin",
  "clientSecret": "web-secret-xxx",
  "grantType": "password",
  "username": "admin",
  "password": "123456"
}
```

**响应**:
```json
{
  "code": 200,
  "data": {
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expires_in": 604800,
    "user_info": {
      "userId": 1,
      "username": "admin",
      "nickname": "管理员",
      "phonenumber": "13800138000",
      "email": "admin@example.com",
      "avatar": "",
      "userType": "sys_user"
    }
  }
}
```

### 2. 短信验证码登录

**步骤 1**: 发送短信验证码
```bash
POST /auth/sms
Content-Type: application/json

{
  "phonenumber": "13800138000"
}
```

**步骤 2**: 使用验证码登录
```bash
POST /login
Content-Type: application/json

{
  "clientKey": "mobile-ios",
  "clientSecret": "ios-secret-xxx",
  "grantType": "sms",
  "phonenumber": "13800138000",
  "code": "123456"
}
```

### 3. 邮箱验证码登录

**步骤 1**: 发送邮箱验证码
```bash
POST /auth/email
Content-Type: application/json

{
  "email": "user@example.com"
}
```

**步骤 2**: 使用验证码登录
```bash
POST /login
Content-Type: application/json

{
  "clientKey": "web-admin",
  "clientSecret": "web-secret-xxx",
  "grantType": "email",
  "email": "user@example.com",
  "code": "123456"
}
```

### 4. 微信小程序登录

```bash
POST /login
Content-Type: application/json

{
  "clientKey": "wechat-xcx",
  "clientSecret": "xcx-secret-xxx",
  "grantType": "xcx",
  "phonenumber": "13800138000",
  "code": "123456",
  "wxCode": "wx_code_from_wechat"
}
```

### 5. 登出

```bash
POST /logout
Authorization: Bearer {access_token}
```

### 6. 获取当前用户信息

```bash
GET /me
Authorization: Bearer {access_token}
```

## 业务代码使用

### 在 Controller 中获取用户信息

```go
package controller

import (
    "github.com/force-c/nai-tizi/internal/container"
    "github.com/force-c/nai-tizi/internal/controller"
    "github.com/force-c/nai-tizi/internal/domain/response"
    "github.com/gin-gonic/gin"
)

type UserController struct {
    ctr  container.Container
    base *controller.BaseController
}

func NewUserController(c container.Container) *UserController {
    return &UserController{
        ctr:  c,
        base: controller.NewBaseController(c),
    }
}

func (h *UserController) GetProfile(c *gin.Context) {
    // 方式 1: 使用便捷方法获取用户ID
    userId, err := h.base.GetUserId(c)
    if err != nil {
        response.FailWithMsg(c, err.Error())
        return
    }

    // 方式 2: 使用便捷方法获取用户名
    userName, err := h.base.GetUserName(c)
    if err != nil {
        response.FailWithMsg(c, err.Error())
        return
    }

    // 方式 3: 获取客户端ID
    clientId, err := h.base.GetClientId(c)
    if err != nil {
        response.FailWithMsg(c, err.Error())
        return
    }

    // 方式 4: 获取设备类型
    deviceType, err := h.base.GetDeviceType(c)
    if err != nil {
        response.FailWithMsg(c, err.Error())
        return
    }

    // 方式 5: 获取完整用户信息
    user, err := h.base.CurrentUser(c)
    if err != nil {
        response.FailWithMsg(c, err.Error())
        return
    }

    response.Success(c, gin.H{
        "userId":     userId,
        "userName":   userName,
        "clientId":   clientId,
        "deviceType": deviceType,
        "user":       user,
    })
}
```

### 直接从 Context 获取

```go
func (h *UserController) SomeAction(c *gin.Context) {
    // 从 context 直接获取（Auth 中间件已设置）
    userId, _ := c.Get("userId")
    userName, _ := c.Get("userName")
    clientId, _ := c.Get("clientId")
    deviceType, _ := c.Get("deviceType")

    // 使用用户信息
    // ...
}
```

## Token 过期机制

### 固定超时 (Timeout)

Token 从生成时刻开始计时，到达 `timeout` 秒后绝对过期，无论是否有活动。

**示例**: Timeout = 604800 秒（7天）
- 2024-01-01 10:00:00 生成 Token
- 2024-01-08 10:00:00 Token 过期（无论期间是否使用）

### 活动超时 (ActiveTimeout)

Token 在 `activeTimeout` 秒内无任何请求则过期，每次请求会刷新活动时间。

**示例**: ActiveTimeout = 1800 秒（30分钟）
- 2024-01-01 10:00:00 最后一次请求
- 2024-01-01 10:30:00 Token 过期（30分钟内无请求）
- 如果在 10:25:00 有请求，则过期时间延长到 10:55:00

### 双重超时组合

Token 同时受两种超时限制，任一条件满足即过期：
- 达到固定超时时间
- 达到活动超时时间

## 安全建议

1. **clientSecret 保护**: 
   - 前端应用不应暴露 clientSecret
   - 建议通过后端代理或使用公钥/私钥方案

2. **Token 存储**:
   - 移动端：使用 Keychain (iOS) 或 KeyStore (Android)
   - Web 端：使用 HttpOnly Cookie 或 SessionStorage

3. **HTTPS**:
   - 生产环境必须使用 HTTPS
   - 防止 Token 在传输过程中被窃取

4. **定期轮换密钥**:
   - 定期更换 clientSecret
   - 定期更换 JWT secret

5. **监控异常登录**:
   - 记录登录日志
   - 监控异常 IP 和设备

## 常见问题

### Q: 如何实现"记住我"功能？

A: 为"记住我"创建单独的客户端配置，设置更长的 `timeout`：

```sql
INSERT INTO sys_client (client_key, client_secret, grant_type, device_type, timeout, active_timeout)
VALUES ('web-admin-remember', 'secret-xxx', 'password', 'pc', 2592000, 86400);
-- timeout = 30天, activeTimeout = 24小时
```

### Q: 如何强制用户重新登录？

A: 调用登出接口或直接删除 Redis 中的 Token 记录：

```bash
# 删除用户的所有 Token
redis-cli DEL "user:token:{userId}:{clientId}"
redis-cli DEL "user:tokens:{userId}:{clientId}"
```

### Q: 如何查看用户的在线状态？

A: 检查 Redis 中的 Token 活动记录：

```bash
# 检查 Token 是否存在
redis-cli EXISTS "token:active:{tokenHash}"

# 查看最后活动时间
redis-cli GET "token:active:{tokenHash}"
```

### Q: 如何自定义 Token 请求头？

A: 修改配置文件中的 `tokenHeader`：

```yaml
auth:
  tokenHeader: "X-Auth-Token"  # 自定义请求头名称
```

前端请求时使用自定义请求头：

```javascript
fetch('/api/me', {
  headers: {
    'X-Auth-Token': 'Bearer ' + token
  }
})
```

## 参考

- [开发规范指南](./开发规范指南.md)
- [配置管理说明](./配置管理说明.md)
- [日志使用指南](./日志使用指南.md)
