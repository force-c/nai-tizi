# 用户角色菜单权限架构说明

## 一、架构模式概述

本系统采用 **RBAC (Role-Based Access Control) + Casbin + 多租户隔离** 的权限管理架构模式。

### 核心特性

- **RBAC 模型**：基于角色的访问控制，用户通过角色获得权限
- **Casbin 引擎**：使用 Casbin 作为权限验证引擎，支持灵活的策略配置
- **多租户隔离**：通过组织ID（orgId）实现租户级别的数据和权限隔离
- **角色继承**：支持角色多继承，子角色自动继承父角色的所有权限
- **通配符权限**：支持 `user.*`、`*.read`、`*` 等通配符权限匹配
- **菜单树结构**：支持目录、菜单、按钮三级菜单结构
- **充血模型**：采用 DDD 充血模型设计，领域逻辑封装在模型层

---

## 二、数据模型设计

### 2.1 核心实体关系图

```
┌─────────────┐
│   s_user    │ 用户
│             │
│ - org_id    │ ←─────┐
└──────┬──────┘       │
       │              │ 1:1
       │ 1:N          │
       ↓              │
┌─────────────┐       │
│s_user_role  │       │
│ (关联表)    │       │
└──────┬──────┘       │
       │              │
       │ N:1          │
       ↓              │
┌─────────────┐       │
│   s_role    │ 角色  │
│             │       │
│ - role_key  │       │
│ - status    │       │
└──────┬──────┘       │
       │              │
       │ 1:N          │
       ↓              │
┌─────────────┐       │
│s_role_menu  │       │
│ (关联表)    │       │
└──────┬──────┘       │
       │              │
       │ N:1          │
       ↓              │
┌─────────────┐       │
│   s_menu    │ 菜单  │
│             │       │
│ - perms     │       │
│ - menu_type │       │
└─────────────┘       │
                      │
┌─────────────┐       │
│   s_org     │ 组织  │
│             │ ──────┘
│ - parent_id │ (树形结构)
└─────────────┘

┌─────────────┐
│s_role_inherit│ 角色继承
│             │
│ - role_id   │ (子角色)
│ - parent_id │ (父角色)
│ - org_id    │ (多租户隔离)
└─────────────┘

┌─────────────┐
│casbin_rule  │ Casbin策略存储
│             │
│ - ptype     │ (p=权限, g=角色)
│ - v0~v5     │ (策略参数)
└─────────────┘
```


### 2.2 数据表详细说明

#### 1. s_user (用户表)

| 字段 | 类型 | 说明 |
|------|------|------|
| id | BIGINT | 用户ID（分布式ID） |
| org_id | BIGINT | 所属组织ID（单一组织） |
| user_name | VARCHAR | 用户名（登录账号，唯一） |
| nick_name | VARCHAR | 昵称（显示名称） |
| password | VARCHAR | 密码（加密存储） |
| status | INTEGER | 状态：0正常 1停用 |
| user_type | INTEGER | 用户类型：0系统用户 1微信用户 2APP用户 |

**关键点**：
- 一个用户只属于一个组织（org_id）
- 一个用户可以拥有多个角色（通过 s_user_role 关联）

#### 2. s_role (角色表)

| 字段 | 类型 | 说明 |
|------|------|------|
| id | BIGINT | 角色ID（分布式ID） |
| role_key | VARCHAR | 角色标识（唯一，用于Casbin匹配） |
| role_name | VARCHAR | 角色名称（显示用） |
| sort | BIGINT | 显示顺序 |
| status | INTEGER | 状态：0正常 1停用 |
| data_scope | INTEGER | 数据范围：1全部 2自定义 3本组织 4本组织及以下 5仅本人 |
| is_system | BOOLEAN | 是否系统内置角色（不可删除） |

**关键点**：
- role_key 是角色的唯一标识，用于 Casbin 权限匹配（如：super_admin、user_manager）
- status 控制角色启用/禁用，禁用后该角色的所有权限失效
- is_system 标记系统内置角色，防止误删除

#### 3. s_menu (菜单权限表)

| 字段 | 类型 | 说明 |
|------|------|------|
| id | BIGINT | 菜单ID（分布式ID） |
| menu_name | VARCHAR | 菜单名称 |
| parent_id | BIGINT | 父菜单ID（0表示根菜单） |
| sort | BIGINT | 显示顺序 |
| path | VARCHAR | 路由地址 |
| component | VARCHAR | 组件路径 |
| menu_type | INTEGER | 菜单类型：0目录 1菜单 2按钮 |
| visible | INTEGER | 显示状态：0显示 1隐藏 |
| status | INTEGER | 状态：0正常 1停用 |
| perms | VARCHAR | 权限标识（如：user.create, user.*, *） |
| icon | VARCHAR | 菜单图标 |

**关键点**：
- 支持三级结构：目录(0) → 菜单(1) → 按钮(2)
- perms 字段存储权限标识，支持通配符（user.*、*.read、*）
- 树形结构通过 parent_id 实现

#### 4. s_user_role (用户角色关联表)

| 字段 | 类型 | 说明 |
|------|------|------|
| id | BIGINT | 主键ID |
| user_id | BIGINT | 用户ID |
| role_id | BIGINT | 角色ID |

**关键点**：
- 多对多关系：一个用户可以有多个角色，一个角色可以分配给多个用户
- 唯一约束：(user_id, role_id) 防止重复分配

#### 5. s_role_menu (角色菜单关联表)

| 字段 | 类型 | 说明 |
|------|------|------|
| id | BIGINT | 主键ID |
| role_id | BIGINT | 角色ID |
| menu_id | BIGINT | 菜单ID |

**关键点**：
- 多对多关系：一个角色可以有多个菜单权限，一个菜单可以分配给多个角色
- 唯一约束：(role_id, menu_id) 防止重复关联

#### 6. s_role_inherit (角色继承关系表)

| 字段 | 类型 | 说明 |
|------|------|------|
| id | BIGINT | 主键ID |
| role_id | BIGINT | 子角色ID |
| parent_id | BIGINT | 父角色ID |
| org_id | BIGINT | 组织ID（多租户隔离） |

**关键点**：
- 支持角色多继承：一个角色可以继承多个父角色
- 子角色自动继承父角色的所有权限
- 通过 org_id 实现多租户隔离
- 系统会检查循环继承，防止死循环
- 继承深度限制为3层

#### 7. s_role_org (角色组织关联表)

| 字段 | 类型 | 说明 |
|------|------|------|
| id | BIGINT | 主键ID |
| role_id | BIGINT | 角色ID |
| org_id | BIGINT | 组织ID |

**关键点**：
- 定义角色在哪些组织中可用
- 实现角色的多租户隔离

#### 8. casbin_rule (Casbin策略存储表)

| 字段 | 类型 | 说明 |
|------|------|------|
| id | BIGINT | 主键ID |
| ptype | VARCHAR | 策略类型：p(权限策略) 或 g(角色继承) |
| v0 | VARCHAR | 主体（角色或用户） |
| v1 | VARCHAR | 域（组织ID）或父角色 |
| v2 | VARCHAR | 对象（资源）或组织ID |
| v3 | VARCHAR | 动作（操作类型） |

**关键点**：
- Casbin 使用此表存储所有权限策略和角色关系
- ptype=p：权限策略，格式 (role::admin, org::1, user.*, write)
- ptype=g：角色关系，格式 (user::1001, role::admin, org::1)


---

## 三、Casbin 权限模型

### 3.1 模型配置 (casbin_model.conf)

```ini
# 请求定义：(用户, 组织, 资源, 操作)
[request_definition]
r = sub, dom, obj, act

# 策略定义：(角色, 组织, 资源, 操作)
[policy_definition]
p = sub, dom, obj, act

# 角色定义：(用户/子角色, 父角色, 组织)
[role_definition]
g = _, _, _

# 策略效果：只要有一条策略允许就允许
[policy_effect]
e = some(where (p.eft == allow))

# 匹配器：支持通配符和角色继承
[matchers]
m = g(r.sub, p.sub, r.dom) && r.dom == p.dom && keyMatch2(r.obj, p.obj) && keyMatch2(r.act, p.act) || p.sub == "role::super_admin" && g(r.sub, p.sub, r.dom) && r.dom == p.dom
```

### 3.2 策略示例

#### 权限策略 (ptype = p)

```
# 超级管理员拥有所有权限
p, role::super_admin, org::1, *, *

# 用户管理员拥有用户模块所有权限
p, role::user_manager, org::1, user.*, write

# 查看者拥有所有模块的读权限
p, role::viewer, org::1, *.read, read

# 设备管理员拥有设备模块的读写权限
p, role::device_manager, org::1, device.*, write
```

#### 角色关系 (ptype = g)

```
# 用户1001在组织1拥有super_admin角色
g, user::1001, role::super_admin, org::1

# 用户1002在组织1拥有user_manager角色
g, user::1002, role::user_manager, org::1

# manager角色继承viewer角色（角色继承）
g, role::manager, role::viewer, org::1
```

### 3.3 权限检查流程

```go
// 检查用户权限
func CheckPermission(userId, orgId int64, resource, action string) (bool, error) {
    // 构造 Casbin 请求参数
    sub := fmt.Sprintf("user::%d", userId)      // 用户：user::1001
    dom := fmt.Sprintf("org::%d", orgId)        // 组织：org::1
    obj := resource                              // 资源：user.create
    act := action                                // 操作：write
    
    // 调用 Casbin 引擎验证
    return enforcer.Enforce(sub, dom, obj, act)
}
```

### 3.4 通配符匹配规则

| 权限标识 | 匹配范围 | 示例 |
|---------|---------|------|
| `user.create` | 精确匹配 | 只匹配 user.create |
| `user.*` | 模块通配 | 匹配 user.create, user.read, user.update, user.delete |
| `*.read` | 操作通配 | 匹配 user.read, role.read, menu.read 等所有读操作 |
| `*` | 全部权限 | 匹配所有资源和操作（超级管理员） |

---

## 四、分层架构设计

### 4.1 架构分层

```
┌─────────────────────────────────────┐
│  Controller Layer (控制器层)        │
│  - 接收HTTP请求                     │
│  - 参数验证                         │
│  - 调用Service层                    │
└──────────────┬──────────────────────┘
               │
               ↓
┌─────────────────────────────────────┐
│  Middleware Layer (中间件层)        │
│  - Auth: 认证中间件                 │
│  - Permission: 权限检查中间件       │
└──────────────┬──────────────────────┘
               │
               ↓
┌─────────────────────────────────────┐
│  Service Layer (服务层)             │
│  - 业务逻辑处理                     │
│  - 事务管理                         │
│  - 调用Domain层和Infrastructure层   │
└──────────────┬──────────────────────┘
               │
               ↓
┌─────────────────────────────────────┐
│  Domain Layer (领域层)              │
│  - 领域模型（充血模型）             │
│  - 领域逻辑封装                     │
│  - 数据库操作方法                   │
└──────────────┬──────────────────────┘
               │
               ↓
┌─────────────────────────────────────┐
│  Infrastructure Layer (基础设施层)  │
│  - 数据库访问（GORM）               │
│  - Casbin引擎                       │
│  - 缓存、日志等                     │
└─────────────────────────────────────┘
```

### 4.2 各层职责详解

#### 1. Controller Layer (控制器层)

**文件位置**：`internal/controller/`

**职责**：
- 接收和解析HTTP请求
- 参数验证（使用 binding tag）
- 调用Service层处理业务逻辑
- 返回HTTP响应

**示例**：
```go
// UserController.Create - 创建用户
func (h *UserController) Create(c *gin.Context) {
    var req request.CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        response.FailCode(c, response.CodeInvalidParam, "参数错误")
        return
    }
    
    // 获取当前用户ID
    currentUserId, _ := h.base.GetUserId(c)
    req.CreateBy = currentUserId
    
    // 调用Service层
    if err := h.userService.Create(c.Request.Context(), &req); err != nil {
        response.Fail(c, err.Error())
        return
    }
    
    response.Success(c, nil)
}
```

#### 2. Middleware Layer (中间件层)

**文件位置**：`internal/middleware/`

**核心中间件**：

##### Auth 中间件
```go
// 认证中间件
func Auth(tokenManager, cfg, db) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 从请求头读取 Token
        token := c.GetHeader("Authorization")
        
        // 2. 验证 Token
        claims, err := tokenManager.ValidateAccessToken(ctx, token)
        
        // 3. 查询用户的组织ID
        user, _ := userModel.FindById(db, claims.UserId)
        
        // 4. 设置用户信息到 context
        c.Set("userId", claims.UserId)
        c.Set("orgId", user.OrgId)
        
        c.Next()
    }
}
```

##### Permission 中间件
```go
// 权限检查中间件
func Permission(casbinService, resource string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 从 context 获取用户信息（由Auth中间件设置）
        userId, _ := c.Get("userId")
        orgId, _ := c.Get("orgId")
        
        // 2. 解析资源和操作
        // resource = "user.create" → obj = "user.create", act = "write"
        // resource = "user.read" → obj = "user.read", act = "read"
        
        // 3. 调用 Casbin 检查权限
        allowed, err := casbinService.CheckPermission(ctx, userId, orgId, obj, act)
        
        if !allowed {
            response.Forbidden(c, "无权限")
            c.Abort()
            return
        }
        
        c.Next()
    }
}
```

#### 3. Service Layer (服务层)

**文件位置**：`internal/service/`

**核心服务**：

##### CasbinService (权限管理服务)
```go
type CasbinService interface {
    // 检查用户权限
    CheckPermission(ctx, userId, orgId, resource, action) (bool, error)
    
    // 用户角色管理
    AddRoleForUser(ctx, userId, roleKey, orgId) error
    DeleteRoleForUser(ctx, userId, roleKey, orgId) error
    GetRolesForUser(ctx, userId, orgId) ([]string, error)
    
    // 角色权限管理
    AddPermissionForRole(ctx, roleKey, orgId, resource, action) error
    DeletePermissionForRole(ctx, roleKey, orgId, resource, action) error
    GetPermissionsForRole(ctx, roleKey, orgId) ([][]string, error)
    
    // 角色继承管理
    SetRoleInherit(ctx, childRoleKey, parentRoleKey, orgId) error
    DeleteRoleInherit(ctx, childRoleKey, parentRoleKey, orgId) error
    CheckCircularInherit(ctx, childRoleKey, parentRoleKey, orgId) (bool, error)
}
```

##### RoleService (角色管理服务)
```go
type RoleService interface {
    // 角色CRUD
    Create(ctx, role) error
    Update(ctx, role) error
    Delete(ctx, roleId) error
    GetById(ctx, roleId) (*Role, error)
    
    // 用户角色分配
    AssignRoleToUser(ctx, userId, roleId, orgId) error
    RemoveRoleFromUser(ctx, userId, roleId, orgId) error
    GetUserRoles(ctx, userId) ([]Role, error)
    
    // 角色菜单权限
    AssignMenusToRole(ctx, roleId, menuIds) error
    GetRoleMenus(ctx, roleId) ([]Menu, error)
}
```

##### MenuService (菜单管理服务)
```go
type MenuService interface {
    // 获取用户菜单树（用于前端路由生成）
    GetUserMenuTree(userId) ([]*MenuTree, error)
    
    // 菜单CRUD
    CreateMenu(menu) error
    UpdateMenu(menu) error
    DeleteMenu(menuId) error
    GetMenuById(menuId) (*Menu, error)
    
    // 菜单树管理
    GetAllMenuTree() ([]*MenuTree, error)
    GetMenuList() ([]Menu, error)
}
```

#### 4. Domain Layer (领域层)

**文件位置**：`internal/domain/model/`

**充血模型设计**：
```go
// User 领域模型（充血模型）
type User struct {
    ID          int64
    OrgId       int64
    UserName    string
    Password    string
    Status      int32
    // ... 其他字段
}

// 领域方法封装在模型内
func (u *User) FindByUsername(db, username) (*User, error)
func (u *User) FindById(db, userId) (*User, error)
func (u *User) Create(db, user) error
func (u *User) Update(db, userId, updates) error
func (u *User) Delete(db, userId) error
```


---

## 五、权限使用流程

### 5.1 完整的请求处理流程

```
1. 用户发起HTTP请求
   ↓
2. Auth中间件：验证Token，设置userId和orgId到context
   ↓
3. Permission中间件：检查用户权限
   ↓
4. Controller：接收请求，调用Service
   ↓
5. Service：执行业务逻辑，调用Domain
   ↓
6. Domain：执行数据库操作
   ↓
7. 返回响应
```

### 5.2 路由权限配置示例

**文件位置**：`internal/router/`

```go
// 用户管理路由
func registerUserRoutes(r *gin.Engine, ctx *RouterContext) {
    users := r.Group("/api/v1/user")
    users.Use(ctx.AuthMiddleware)  // 先认证
    {
        // 创建用户 - 需要 user.create 权限
        users.POST("", 
            middleware.Permission(ctx.CasbinService, constants.ResourceUserCreate), 
            userController.Create)
        
        // 查询用户 - 需要 user.read 权限
        users.GET("/:id", 
            middleware.Permission(ctx.CasbinService, constants.ResourceUserRead), 
            userController.GetById)
        
        // 更新用户 - 需要 user.update 权限
        users.PUT("/:id", 
            middleware.Permission(ctx.CasbinService, constants.ResourceUserUpdate), 
            userController.Update)
        
        // 删除用户 - 需要 user.delete 权限
        users.DELETE("/:id", 
            middleware.Permission(ctx.CasbinService, constants.ResourceUserDelete), 
            userController.Delete)
    }
}

// 角色管理路由
func registerRoleRoutes(r *gin.Engine, ctx *RouterContext) {
    roles := r.Group("/api/v1/role")
    roles.Use(ctx.AuthMiddleware)
    {
        // 角色创建 - 需要 role.create 权限
        roles.POST("", 
            middleware.Permission(ctx.CasbinService, constants.ResourceRoleCreate), 
            roleController.CreateRole)
        
        // 用户角色分配 - 需要 role.assign 权限
        roles.POST("/assign", 
            middleware.Permission(ctx.CasbinService, constants.ResourceRoleAssign), 
            roleController.AssignRoleToUser)
        
        // 角色权限管理 - 需要 role.permission 权限（高级权限）
        roles.POST("/permission", 
            middleware.Permission(ctx.CasbinService, constants.ResourceRolePermission), 
            roleController.AddRolePermission)
        
        // 角色继承管理 - 需要 role.inherit 权限（高级权限）
        roles.POST("/inherit", 
            middleware.Permission(ctx.CasbinService, constants.ResourceRoleInherit), 
            roleController.SetRoleInherit)
    }
}

// 菜单管理路由
func registerMenuRoutes(r *gin.Engine, ctx *RouterContext) {
    menus := r.Group("/api/v1/menu")
    menus.Use(ctx.AuthMiddleware)
    {
        // 获取当前用户的菜单树 - 所有登录用户都可以访问（无需额外权限）
        menus.GET("/user/tree", menuController.GetUserMenuTree)
        
        // 菜单管理 - 需要 menu.read/create/update/delete 权限
        menus.GET("/tree", 
            middleware.Permission(ctx.CasbinService, constants.ResourceMenuRead), 
            menuController.GetMenuTree)
        
        menus.POST("", 
            middleware.Permission(ctx.CasbinService, constants.ResourceMenuCreate), 
            menuController.CreateMenu)
    }
}
```

### 5.3 权限常量定义

**文件位置**：`internal/constants/permission.go`

```go
const (
    // 角色管理
    ResourceRole           = "role"
    ResourceRoleRead       = "role.read"
    ResourceRoleCreate     = "role.create"
    ResourceRoleUpdate     = "role.update"
    ResourceRoleDelete     = "role.delete"
    ResourceRoleAssign     = "role.assign"        // 用户角色分配
    ResourceRolePermission = "role.permission"    // 角色权限管理（高级）
    ResourceRoleInherit    = "role.inherit"       // 角色继承管理（高级）
    
    // 用户管理
    ResourceUser       = "user"
    ResourceUserRead   = "user.read"
    ResourceUserCreate = "user.create"
    ResourceUserUpdate = "user.update"
    ResourceUserDelete = "user.delete"
    
    // 菜单管理
    ResourceMenu       = "menu"
    ResourceMenuRead   = "menu.read"
    ResourceMenuCreate = "menu.create"
    ResourceMenuUpdate = "menu.update"
    ResourceMenuDelete = "menu.delete"
    
    // 组织管理
    ResourceOrg       = "org"
    ResourceOrgRead   = "org.read"
    ResourceOrgCreate = "org.create"
    ResourceOrgUpdate = "org.update"
    ResourceOrgDelete = "org.delete"
    
    // ... 其他模块权限
)
```

---

## 六、业务场景示例

### 6.1 场景1：创建用户并分配角色

```go
// 1. 创建用户
user := &model.User{
    OrgId:    1,                    // 所属组织
    UserName: "zhangsan",
    Password: "encrypted_password",
    Status:   0,                    // 正常
}
userService.Create(ctx, user)

// 2. 为用户分配角色
roleService.AssignRoleToUser(ctx, user.ID, roleId, orgId)

// 3. Casbin 自动同步角色关系
// casbin_rule 表会自动插入：
// ptype=g, v0=user::1001, v1=role::developer, v2=org::1
```

### 6.2 场景2：创建角色并配置权限

```go
// 1. 创建角色
role := &model.Role{
    RoleKey:  "project_manager",
    RoleName: "项目经理",
    Status:   0,
    Sort:     5,
}
roleService.Create(ctx, role)

// 2. 为角色分配菜单权限
menuIds := []int64{100, 101, 102}  // 项目管理、任务管理、团队管理
roleService.AssignMenusToRole(ctx, role.ID, menuIds)

// 3. 为角色添加API权限（通过Casbin）
casbinService.AddPermissionForRole(ctx, "project_manager", orgId, "project.*", "write")
casbinService.AddPermissionForRole(ctx, "project_manager", orgId, "task.*", "write")

// 4. casbin_rule 表会插入：
// ptype=p, v0=role::project_manager, v1=org::1, v2=project.*, v3=write
// ptype=p, v0=role::project_manager, v1=org::1, v2=task.*, v3=write
```

### 6.3 场景3：设置角色继承

```go
// 场景：manager 角色继承 viewer 角色的所有权限

// 1. 设置角色继承
casbinService.SetRoleInherit(ctx, "manager", "viewer", orgId)

// 2. casbin_rule 表会插入：
// ptype=g, v0=role::manager, v1=role::viewer, v2=org::1

// 3. 效果：
// - viewer 角色有权限：*.read (所有模块的读权限)
// - manager 角色自动继承 viewer 的所有权限
// - manager 角色还可以有自己的额外权限
```

### 6.4 场景4：获取用户菜单树

```go
// 前端调用 GET /api/v1/menu/user/tree

// 1. MenuService.GetUserMenuTree(userId)
func (s *MenuService) GetUserMenuTree(userId int64) ([]*MenuTree, error) {
    // 2. 获取用户的所有角色
    roles, _ := roleModel.FindByUserId(db, userId)
    
    // 3. 检查是否是超级管理员
    isSuperAdmin := false
    for _, role := range roles {
        if role.RoleKey == "super_admin" {
            isSuperAdmin = true
        }
    }
    
    // 4. 获取菜单列表
    var menus []model.Menu
    if isSuperAdmin {
        // 超级管理员：获取所有菜单
        menus, _ = menuModel.FindAll(db)
    } else {
        // 普通用户：根据角色获取菜单
        roleIds := extractRoleIds(roles)
        menus, _ = menuModel.FindByRoleIds(db, roleIds)
    }
    
    // 5. 过滤掉按钮类型和停用/隐藏的菜单
    filteredMenus := filterMenus(menus)
    
    // 6. 构建菜单树
    return buildMenuTree(filteredMenus, 0)
}
```

### 6.5 场景5：权限检查流程

```go
// 用户请求：POST /api/v1/user (创建用户)

// 1. Auth中间件
// - 验证Token
// - 设置 userId=1001, orgId=1 到context

// 2. Permission中间件
// - 从context获取 userId=1001, orgId=1
// - 资源：constants.ResourceUserCreate = "user.create"
// - 解析：obj="user.create", act="write"

// 3. CasbinService.CheckPermission
sub := "user::1001"
dom := "org::1"
obj := "user.create"
act := "write"

// 4. Casbin引擎匹配
// - 查询 casbin_rule 表
// - 查找用户的角色：g, user::1001, role::user_manager, org::1
// - 查找角色的权限：p, role::user_manager, org::1, user.*, write
// - 匹配：user.create 匹配 user.* ✓
// - 返回：true（允许访问）

// 5. Controller.Create
// - 执行创建用户逻辑
```


---

## 七、核心特性详解

### 7.1 多租户隔离

**实现方式**：
- 每个用户属于一个组织（user.org_id）
- 权限检查时必须传入组织ID（orgId）
- Casbin策略中包含组织维度（dom = org::1）
- 不同组织的用户权限完全隔离

**示例**：
```go
// 组织1的用户
CheckPermission(userId=1001, orgId=1, "user.create", "write") → true

// 组织2的用户（即使有相同角色）
CheckPermission(userId=1001, orgId=2, "user.create", "write") → false
```

### 7.2 角色继承

**特性**：
- 支持多继承：一个角色可以继承多个父角色
- 自动权限继承：子角色自动拥有父角色的所有权限
- 循环检测：系统会检测并阻止循环继承
- 深度限制：继承深度最多3层

**示例**：
```
super_admin (所有权限)
    ↑
    │ 继承
    │
manager (管理权限)
    ↑
    │ 继承
    │
viewer (只读权限)
```

**代码实现**：
```go
// 设置继承关系
casbinService.SetRoleInherit(ctx, "manager", "viewer", orgId)

// 检查循环继承
circular, _ := casbinService.CheckCircularInherit(ctx, "viewer", "manager", orgId)
if circular {
    return errors.New("检测到循环继承")
}

// 获取继承深度
depth, _ := casbinService.GetInheritDepth(ctx, "manager", orgId)
if depth > 3 {
    return errors.New("继承深度超过限制")
}
```

### 7.3 通配符权限

**支持的通配符模式**：

| 模式 | 说明 | 匹配示例 |
|------|------|---------|
| `resource.action` | 精确匹配 | `user.create` 只匹配 user.create |
| `resource.*` | 资源模块通配 | `user.*` 匹配 user.create, user.read, user.update, user.delete |
| `*.action` | 操作类型通配 | `*.read` 匹配 user.read, role.read, menu.read |
| `*` | 全部权限 | `*` 匹配所有资源和操作 |

**使用场景**：
```go
// 1. 超级管理员：所有权限
AddPermissionForRole("super_admin", orgId, "*", "*")

// 2. 模块管理员：某个模块的所有权限
AddPermissionForRole("user_manager", orgId, "user.*", "write")

// 3. 只读用户：所有模块的读权限
AddPermissionForRole("viewer", orgId, "*.read", "read")

// 4. 特定权限：精确控制
AddPermissionForRole("operator", orgId, "user.create", "write")
AddPermissionForRole("operator", orgId, "user.read", "read")
```

### 7.4 菜单树结构

**三级结构**：
```
目录 (menu_type=0)
  └─ 菜单 (menu_type=1)
      └─ 按钮 (menu_type=2)
```

**示例**：
```
系统管理 (目录)
  ├─ 用户管理 (菜单)
  │   ├─ 新增 (按钮, perms=user.create)
  │   ├─ 编辑 (按钮, perms=user.update)
  │   └─ 删除 (按钮, perms=user.delete)
  ├─ 角色管理 (菜单)
  │   ├─ 新增 (按钮, perms=role.create)
  │   └─ 分配权限 (按钮, perms=role.permission)
  └─ 菜单管理 (菜单)
```

**领域规则**：
```go
// Menu 领域模型中的规则
func (m *Menu) CanHaveChild(childType int32) bool {
    // 目录下可以创建目录或菜单，但不能直接创建按钮
    if m.IsDirectory() && childType == 2 {
        return false
    }
    // 菜单下只能创建按钮
    if m.IsMenu() && childType != 2 {
        return false
    }
    // 按钮下不能创建子节点
    if m.IsButton() {
        return false
    }
    return true
}
```

### 7.5 充血模型设计

**传统贫血模型 vs 充血模型**：

```go
// 贫血模型（不推荐）
type User struct {
    ID       int64
    UserName string
}
// 所有逻辑都在Service层

// 充血模型（本系统采用）
type User struct {
    ID       int64
    UserName string
}

// 领域逻辑封装在模型内
func (u *User) FindByUsername(db, username) (*User, error) { ... }
func (u *User) Create(db, user) error { ... }
func (u *User) Update(db, userId, updates) error { ... }
func (u *User) IsActive() bool { return u.Status == 0 }
func (u *User) CanLogin() bool { return u.Status == 0 && u.Password != "" }
```

**优势**：
- 领域逻辑内聚，易于维护
- 模型自包含，可复用性高
- 符合DDD设计原则
- 业务规则集中管理

---

## 八、数据流转示例

### 8.1 用户登录并获取菜单

```
1. 用户登录
   POST /api/v1/auth/login
   { "username": "zhangsan", "password": "123456" }
   ↓
2. 验证用户名密码
   ↓
3. 生成Token
   { "accessToken": "eyJhbGc...", "userId": 1001, "orgId": 1 }
   ↓
4. 前端存储Token，请求用户菜单
   GET /api/v1/menu/user/tree
   Header: Authorization: Bearer eyJhbGc...
   ↓
5. Auth中间件验证Token
   设置 userId=1001, orgId=1 到context
   ↓
6. MenuService.GetUserMenuTree(1001)
   ↓
7. 查询用户角色
   SELECT * FROM s_role r
   JOIN s_user_role ur ON r.id = ur.role_id
   WHERE ur.user_id = 1001
   → roles: [developer, tester]
   ↓
8. 查询角色菜单
   SELECT DISTINCT m.* FROM s_menu m
   JOIN s_role_menu rm ON m.id = rm.menu_id
   WHERE rm.role_id IN (10, 11)
   AND m.status = 0 AND m.visible = 0
   AND m.menu_type IN (0, 1)  -- 只要目录和菜单
   ↓
9. 构建菜单树
   [
     {
       "id": 1,
       "menuName": "系统管理",
       "menuType": 0,
       "children": [
         {
           "id": 10,
           "menuName": "用户管理",
           "menuType": 1,
           "path": "/system/user",
           "component": "system/user/index"
         }
       ]
     }
   ]
   ↓
10. 前端根据菜单树生成动态路由
```

### 8.2 用户访问受保护的API

```
1. 用户请求创建用户
   POST /api/v1/user
   Header: Authorization: Bearer eyJhbGc...
   Body: { "userName": "lisi", "orgId": 1, ... }
   ↓
2. Auth中间件
   - 验证Token ✓
   - 设置 userId=1001, orgId=1 到context
   ↓
3. Permission中间件
   - 获取 userId=1001, orgId=1
   - 资源：constants.ResourceUserCreate = "user.create"
   - 解析：obj="user.create", act="write"
   ↓
4. CasbinService.CheckPermission(1001, 1, "user.create", "write")
   ↓
5. Casbin引擎查询
   sub = "user::1001"
   dom = "org::1"
   obj = "user.create"
   act = "write"
   ↓
6. 查询 casbin_rule 表
   -- 查找用户角色
   SELECT * FROM casbin_rule
   WHERE ptype = 'g'
   AND v0 = 'user::1001'
   AND v2 = 'org::1'
   → v1 = 'role::user_manager'
   
   -- 查找角色权限
   SELECT * FROM casbin_rule
   WHERE ptype = 'p'
   AND v0 = 'role::user_manager'
   AND v1 = 'org::1'
   → v2 = 'user.*', v3 = 'write'
   ↓
7. 通配符匹配
   keyMatch2("user.create", "user.*") → true ✓
   keyMatch2("write", "write") → true ✓
   ↓
8. 权限检查通过，继续执行
   ↓
9. UserController.Create
   - 参数验证
   - 调用 UserService.Create
   ↓
10. UserService.Create
    - 业务逻辑处理
    - 调用 User.Create(db, user)
    ↓
11. User.Create (领域模型)
    - 执行数据库插入
    - INSERT INTO s_user ...
    ↓
12. 返回成功响应
    { "code": 200, "message": "success" }
```

### 8.3 角色权限变更的同步

```
1. 管理员为角色添加权限
   POST /api/v1/role/permission
   {
     "roleKey": "user_manager",
     "orgId": 1,
     "resource": "device.*",
     "action": "write"
   }
   ↓
2. RoleController.AddRolePermission
   ↓
3. RoleService.AddRolePermission
   ↓
4. CasbinService.AddPermissionForRole
   ↓
5. Casbin引擎添加策略
   enforcer.AddPolicy(
     "role::user_manager",
     "org::1",
     "device.*",
     "write"
   )
   ↓
6. 自动同步到 casbin_rule 表
   INSERT INTO casbin_rule
   (ptype, v0, v1, v2, v3)
   VALUES
   ('p', 'role::user_manager', 'org::1', 'device.*', 'write')
   ↓
7. 权限立即生效
   - 所有拥有 user_manager 角色的用户
   - 立即获得 device.* 的 write 权限
   - 无需重新登录
```


---

## 九、关键代码实现

### 9.1 Casbin权限检查核心代码

```go
// internal/service/casbin.go

// CheckPermission 检查用户权限
func (s *casbinService) CheckPermission(ctx context.Context, userId, orgId int64, resource, action string) (bool, error) {
    // 构造 Casbin 请求参数
    sub := fmt.Sprintf("user::%d", userId)      // 用户：user::1001
    dom := fmt.Sprintf("org::%d", orgId)        // 组织：org::1
    obj := resource                              // 资源：user.create
    act := action                                // 操作：write
    
    // 调用 Casbin 引擎验证
    allowed, err := s.enforcer.Enforce(sub, dom, obj, act)
    if err != nil {
        s.logger.Error("权限检查失败", zap.Error(err))
        return false, err
    }
    
    s.logger.Debug("权限检查",
        zap.Int64("userId", userId),
        zap.Int64("orgId", orgId),
        zap.String("resource", resource),
        zap.String("action", action),
        zap.Bool("allowed", allowed))
    
    return allowed, nil
}

// AddRoleForUser 为用户分配角色
func (s *casbinService) AddRoleForUser(ctx context.Context, userId int64, roleKey string, orgId int64) error {
    sub := fmt.Sprintf("user::%d", userId)
    role := fmt.Sprintf("role::%s", roleKey)
    dom := fmt.Sprintf("org::%d", orgId)
    
    // 添加角色关系到 Casbin
    _, err := s.enforcer.AddGroupingPolicy(sub, role, dom)
    if err != nil {
        return fmt.Errorf("添加用户角色失败: %w", err)
    }
    
    // Casbin 会自动同步到 casbin_rule 表
    // ptype=g, v0=user::1001, v1=role::developer, v2=org::1
    
    return nil
}

// AddPermissionForRole 为角色添加权限
func (s *casbinService) AddPermissionForRole(ctx context.Context, roleKey string, orgId int64, resource, action string) error {
    sub := fmt.Sprintf("role::%s", roleKey)
    dom := fmt.Sprintf("org::%d", orgId)
    
    // 添加权限策略到 Casbin
    _, err := s.enforcer.AddPolicy(sub, dom, resource, action)
    if err != nil {
        return fmt.Errorf("添加角色权限失败: %w", err)
    }
    
    // Casbin 会自动同步到 casbin_rule 表
    // ptype=p, v0=role::developer, v1=org::1, v2=user.*, v3=write
    
    return nil
}

// SetRoleInherit 设置角色继承
func (s *casbinService) SetRoleInherit(ctx context.Context, childRoleKey, parentRoleKey string, orgId int64) error {
    // 1. 检查循环继承
    circular, err := s.CheckCircularInherit(ctx, childRoleKey, parentRoleKey, orgId)
    if err != nil {
        return err
    }
    if circular {
        return errors.New("检测到循环继承，无法设置")
    }
    
    // 2. 检查继承深度
    depth, err := s.GetInheritDepth(ctx, childRoleKey, orgId)
    if err != nil {
        return err
    }
    if depth >= 3 {
        return errors.New("继承深度超过限制（最多3层）")
    }
    
    // 3. 添加继承关系
    child := fmt.Sprintf("role::%s", childRoleKey)
    parent := fmt.Sprintf("role::%s", parentRoleKey)
    dom := fmt.Sprintf("org::%d", orgId)
    
    _, err = s.enforcer.AddGroupingPolicy(child, parent, dom)
    if err != nil {
        return fmt.Errorf("设置角色继承失败: %w", err)
    }
    
    // Casbin 会自动同步到 casbin_rule 表
    // ptype=g, v0=role::manager, v1=role::viewer, v2=org::1
    
    return nil
}
```

### 9.2 Permission中间件核心代码

```go
// internal/middleware/permission.go

func Permission(casbinService service.CasbinService, resource string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 从 context 获取用户信息（由 Auth 中间件设置）
        userIdVal, exists := c.Get("userId")
        if !exists {
            response.Forbidden(c, "用户信息不存在")
            c.Abort()
            return
        }
        userId, ok := userIdVal.(int64)
        if !ok {
            response.Forbidden(c, "用户ID格式错误")
            c.Abort()
            return
        }
        
        // 2. 获取组织ID
        var orgId int64
        orgIdVal, exists := c.Get("orgId")
        if exists {
            orgId, _ = orgIdVal.(int64)
        }
        if orgId == 0 {
            orgId = 1  // 默认组织
        }
        
        // 3. 解析资源和操作
        // resource = "user.create" → obj = "user.create", act = "write"
        // resource = "user.read" → obj = "user.read", act = "read"
        obj := resource
        act := "write"
        if strings.HasSuffix(resource, ".read") {
            act = "read"
        }
        
        // 4. 检查权限
        allowed, err := casbinService.CheckPermission(c.Request.Context(), userId, orgId, obj, act)
        if err != nil {
            response.ServerError(c, "权限检查失败")
            c.Abort()
            return
        }
        
        if !allowed {
            response.Forbidden(c, "无权限访问")
            c.Abort()
            return
        }
        
        // 5. 权限检查通过，继续执行
        c.Next()
    }
}
```

### 9.3 MenuService获取用户菜单树

```go
// internal/service/menu.go

func (s *MenuService) GetUserMenuTree(userId int64) ([]*MenuTree, error) {
    // 1. 获取用户的所有角色
    roleModel := &model.Role{}
    roles, err := roleModel.FindByUserId(s.db, userId)
    if err != nil {
        return nil, fmt.Errorf("获取用户角色失败: %w", err)
    }
    
    if len(roles) == 0 {
        return []*MenuTree{}, nil
    }
    
    // 2. 检查是否是超级管理员
    isSuperAdmin := false
    roleIds := make([]int64, len(roles))
    for i, role := range roles {
        roleIds[i] = role.ID
        if role.RoleKey == "super_admin" {
            isSuperAdmin = true
        }
    }
    
    // 3. 获取菜单列表
    var menus []model.Menu
    menuModel := &model.Menu{}
    
    if isSuperAdmin {
        // 超级管理员：获取所有菜单
        menus, err = menuModel.FindAll(s.db)
    } else {
        // 普通用户：根据角色获取菜单
        menus, err = menuModel.FindByRoleIds(s.db, roleIds)
    }
    
    if err != nil {
        return nil, fmt.Errorf("获取菜单列表失败: %w", err)
    }
    
    // 4. 过滤菜单
    var filteredMenus []model.Menu
    for _, menu := range menus {
        // 只保留目录(0)和菜单(1)，且状态正常、可见
        if (menu.MenuType == 0 || menu.MenuType == 1) &&
            menu.Status == 0 && menu.Visible == 0 {
            filteredMenus = append(filteredMenus, menu)
        }
    }
    
    // 5. 构建菜单树
    return s.buildMenuTree(filteredMenus, 0), nil
}

// buildMenuTree 递归构建菜单树
func (s *MenuService) buildMenuTree(menus []model.Menu, parentId int64) []*MenuTree {
    var tree []*MenuTree
    
    for _, menu := range menus {
        if menu.ParentId == parentId {
            node := &MenuTree{
                Menu:     menu,
                Children: s.buildMenuTree(menus, menu.ID),
            }
            tree = append(tree, node)
        }
    }
    
    return tree
}
```

### 9.4 Role领域模型查询方法

```go
// internal/domain/model/s_role.go

// FindByUserId 根据用户ID查询角色列表
func (r *Role) FindByUserId(db *gorm.DB, userId int64) ([]Role, error) {
    var roles []Role
    
    // 通过 s_user_role 关联表查询
    err := db.Table("s_role r").
        Select("r.*").
        Joins("INNER JOIN s_user_role ur ON r.id = ur.role_id").
        Where("ur.user_id = ? AND r.status = 0", userId).
        Order("r.sort ASC").
        Find(&roles).Error
    
    if err != nil {
        return nil, err
    }
    
    return roles, nil
}
```

### 9.5 Menu领域模型查询方法

```go
// internal/domain/model/s_menu.go

// FindByRoleIds 根据角色ID列表查询菜单
func (m *Menu) FindByRoleIds(db *gorm.DB, roleIds []int64) ([]Menu, error) {
    var menus []Menu
    
    // 通过 s_role_menu 关联表查询
    err := db.Table("s_menu m").
        Select("DISTINCT m.*").
        Joins("INNER JOIN s_role_menu rm ON m.id = rm.menu_id").
        Where("rm.role_id IN (?) AND m.status = 0", roleIds).
        Order("m.sort ASC").
        Find(&menus).Error
    
    if err != nil {
        return nil, err
    }
    
    return menus, nil
}

// FindAll 查询所有菜单
func (m *Menu) FindAll(db *gorm.DB) ([]Menu, error) {
    var menus []Menu
    err := db.Where("status = 0").Order("sort ASC").Find(&menus).Error
    return menus, err
}

// CanHaveChild 检查是否可以创建子菜单（领域规则）
func (m *Menu) CanHaveChild(childType int32) bool {
    // 目录下可以创建目录或菜单，但不能直接创建按钮
    if m.IsDirectory() && childType == 2 {
        return false
    }
    // 菜单下只能创建按钮
    if m.IsMenu() && childType != 2 {
        return false
    }
    // 按钮下不能创建子节点
    if m.IsButton() {
        return false
    }
    return true
}

// IsDirectory 是否是目录
func (m *Menu) IsDirectory() bool {
    return m.MenuType == 0
}

// IsMenu 是否是菜单
func (m *Menu) IsMenu() bool {
    return m.MenuType == 1
}

// IsButton 是否是按钮
func (m *Menu) IsButton() bool {
    return m.MenuType == 2
}
```

---

## 十、架构优势与最佳实践

### 10.1 架构优势

#### 1. 灵活的权限控制
- **通配符支持**：`user.*`、`*.read`、`*` 等模式，减少权限配置工作量
- **角色继承**：支持多继承，权限管理更灵活
- **动态权限**：权限变更立即生效，无需重启服务

#### 2. 清晰的分层设计
- **职责分离**：Controller、Service、Domain各司其职
- **易于测试**：每层可独立测试
- **易于维护**：修改某层不影响其他层

#### 3. 充血模型设计
- **领域逻辑内聚**：业务规则封装在模型内
- **高复用性**：模型方法可在多处复用
- **符合DDD**：遵循领域驱动设计原则

#### 4. 多租户隔离
- **数据隔离**：不同组织的数据完全隔离
- **权限隔离**：不同组织的权限互不影响
- **安全可靠**：防止跨租户访问

#### 5. 高性能
- **Casbin缓存**：权限检查结果可缓存
- **索引优化**：关键字段都有索引
- **批量操作**：支持批量权限配置

### 10.2 最佳实践

#### 1. 权限粒度设计

**推荐**：
```go
// 模块级权限（粗粒度）
user.*          // 用户模块所有权限
role.*          // 角色模块所有权限

// 操作级权限（细粒度）
user.create     // 创建用户
user.read       // 查询用户
user.update     // 更新用户
user.delete     // 删除用户
```

**不推荐**：
```go
// 过于细粒度（维护成本高）
user.create.admin
user.create.normal
user.read.list
user.read.detail
```

#### 2. 角色设计

**推荐的角色层次**：
```
super_admin (超级管理员)
  ├─ admin (管理员)
  │   ├─ user_manager (用户管理员)
  │   ├─ role_manager (角色管理员)
  │   └─ menu_manager (菜单管理员)
  ├─ operator (操作员)
  │   ├─ data_operator (数据操作员)
  │   └─ audit_operator (审计操作员)
  └─ viewer (查看者)
```

#### 3. 菜单权限配置

**推荐**：
```
系统管理 (目录, perms="")
  ├─ 用户管理 (菜单, perms="user.read")
  │   ├─ 新增 (按钮, perms="user.create")
  │   ├─ 编辑 (按钮, perms="user.update")
  │   └─ 删除 (按钮, perms="user.delete")
```

**说明**：
- 目录不需要权限标识
- 菜单使用读权限（进入页面需要读权限）
- 按钮使用具体操作权限

#### 4. 权限检查位置

**推荐**：
```go
// 在路由层统一检查权限
users.POST("", 
    middleware.Permission(casbinService, constants.ResourceUserCreate), 
    userController.Create)
```

**不推荐**：
```go
// 在Controller或Service中分散检查权限
func (c *UserController) Create(ctx *gin.Context) {
    // 不推荐在这里检查权限
    if !checkPermission(...) {
        return
    }
    ...
}
```

#### 5. 错误处理

**推荐**：
```go
// 明确的错误信息
if !allowed {
    response.Forbidden(c, "无权限访问")
    return
}

// 详细的日志记录
s.logger.Error("权限检查失败",
    zap.Int64("userId", userId),
    zap.String("resource", resource),
    zap.Error(err))
```


---

## 十一、常见问题与解决方案

### 11.1 权限相关问题

#### Q1: 用户权限变更后需要重新登录吗？

**A**: 不需要。权限变更会立即生效。

**原因**：
- 每次请求都会实时查询 Casbin 策略
- Casbin 策略存储在数据库中（casbin_rule表）
- 权限变更会立即同步到数据库
- 下次请求时会使用最新的权限策略

#### Q2: 如何实现"查看所有"和"仅查看自己"的数据权限？

**A**: 使用 data_scope 字段配合业务逻辑实现。

```go
// s_role 表中的 data_scope 字段
// 1: 全部数据
// 2: 自定义数据
// 3: 本组织数据
// 4: 本组织及以下数据
// 5: 仅本人数据

// 在Service层根据 data_scope 构建查询条件
func (s *UserService) List(ctx context.Context, userId int64) ([]User, error) {
    // 获取用户的角色
    roles, _ := s.roleService.GetUserRoles(ctx, userId)
    
    // 获取最大的数据范围
    maxDataScope := 5  // 默认仅本人
    for _, role := range roles {
        if role.DataScope < maxDataScope {
            maxDataScope = role.DataScope
        }
    }
    
    // 根据数据范围构建查询
    query := s.db.Model(&User{})
    switch maxDataScope {
    case 1:
        // 全部数据，不添加条件
    case 3:
        // 本组织数据
        user, _ := s.GetById(ctx, userId)
        query = query.Where("org_id = ?", user.OrgId)
    case 5:
        // 仅本人数据
        query = query.Where("id = ?", userId)
    }
    
    var users []User
    query.Find(&users)
    return users, nil
}
```

#### Q3: 如何实现临时权限或权限过期？

**A**: 可以扩展 casbin_rule 表，添加过期时间字段。

```sql
-- 扩展 casbin_rule 表
ALTER TABLE casbin_rule ADD COLUMN expire_at TIMESTAMP;

-- 在权限检查时过滤过期策略
SELECT * FROM casbin_rule
WHERE ptype = 'p'
AND (expire_at IS NULL OR expire_at > NOW());
```

#### Q4: 如何实现按钮级别的权限控制？

**A**: 前端根据用户菜单树中的按钮权限控制显示。

```javascript
// 前端代码示例
// 1. 获取用户菜单树（包含按钮）
const menuTree = await api.getUserMenuTree();

// 2. 提取所有权限标识
const permissions = extractPermissions(menuTree);
// permissions = ['user.create', 'user.update', 'user.delete', ...]

// 3. 在组件中检查权限
<button v-if="hasPermission('user.create')">新增</button>
<button v-if="hasPermission('user.update')">编辑</button>
<button v-if="hasPermission('user.delete')">删除</button>

// 4. 权限检查函数
function hasPermission(perm) {
  return permissions.includes(perm);
}
```

### 11.2 性能相关问题

#### Q5: 权限检查会影响性能吗？

**A**: 影响很小，可以通过缓存进一步优化。

**优化方案**：
```go
// 1. 使用 Casbin 内置缓存
enforcer.EnableCache(true)

// 2. 使用 Redis 缓存用户角色
func (s *casbinService) GetUserRoles(userId, orgId int64) ([]string, error) {
    // 先从 Redis 获取
    cacheKey := fmt.Sprintf("user:roles:%d:%d", userId, orgId)
    if roles, err := s.redis.Get(cacheKey); err == nil {
        return roles, nil
    }
    
    // Redis 没有，从数据库查询
    roles, err := s.enforcer.GetRolesForUser(...)
    if err != nil {
        return nil, err
    }
    
    // 缓存到 Redis（5分钟过期）
    s.redis.Set(cacheKey, roles, 5*time.Minute)
    
    return roles, nil
}

// 3. 权限变更时清除缓存
func (s *casbinService) AddRoleForUser(userId, roleKey, orgId int64) error {
    // 添加角色
    err := s.enforcer.AddGroupingPolicy(...)
    
    // 清除缓存
    cacheKey := fmt.Sprintf("user:roles:%d:%d", userId, orgId)
    s.redis.Del(cacheKey)
    
    return err
}
```

#### Q6: 大量用户时如何优化菜单查询？

**A**: 使用缓存和批量查询。

```go
// 1. 缓存角色菜单映射
func (s *MenuService) GetRoleMenus(roleId int64) ([]Menu, error) {
    cacheKey := fmt.Sprintf("role:menus:%d", roleId)
    
    // 从缓存获取
    if menus, err := s.cache.Get(cacheKey); err == nil {
        return menus, nil
    }
    
    // 从数据库查询
    menus, err := s.menuModel.FindByRoleIds(s.db, []int64{roleId})
    
    // 缓存结果（10分钟）
    s.cache.Set(cacheKey, menus, 10*time.Minute)
    
    return menus, err
}

// 2. 批量查询用户角色
func (s *RoleService) GetUsersRoles(userIds []int64) (map[int64][]Role, error) {
    var userRoles []struct {
        UserId int64
        Role   Role
    }
    
    // 一次查询获取所有用户的角色
    err := s.db.Table("s_user_role ur").
        Select("ur.user_id, r.*").
        Joins("INNER JOIN s_role r ON ur.role_id = r.id").
        Where("ur.user_id IN (?)", userIds).
        Scan(&userRoles).Error
    
    // 组装结果
    result := make(map[int64][]Role)
    for _, ur := range userRoles {
        result[ur.UserId] = append(result[ur.UserId], ur.Role)
    }
    
    return result, err
}
```

### 11.3 数据一致性问题

#### Q7: 如何保证用户角色和Casbin策略的一致性？

**A**: 使用事务确保数据一致性。

```go
func (s *RoleService) AssignRoleToUser(ctx context.Context, userId, roleId, orgId int64) error {
    // 开启事务
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 1. 插入 s_user_role 表
        userRole := &model.SUserRole{
            UserId: userId,
            RoleId: roleId,
        }
        if err := tx.Create(userRole).Error; err != nil {
            return err
        }
        
        // 2. 获取角色信息
        role, err := (&model.Role{}).FindByID(tx, roleId)
        if err != nil {
            return err
        }
        
        // 3. 同步到 Casbin
        err = s.casbinService.AddRoleForUser(ctx, userId, role.RoleKey, orgId)
        if err != nil {
            return err
        }
        
        return nil
    })
}
```

#### Q8: 删除角色时如何处理已分配的用户？

**A**: 级联删除或阻止删除。

```go
func (s *RoleService) Delete(ctx context.Context, roleId int64) error {
    // 1. 检查是否有用户使用该角色
    var count int64
    s.db.Model(&model.SUserRole{}).Where("role_id = ?", roleId).Count(&count)
    
    if count > 0 {
        return errors.New("该角色已分配给用户，无法删除")
    }
    
    // 2. 检查是否是系统内置角色
    role, err := (&model.Role{}).FindByID(s.db, roleId)
    if err != nil {
        return err
    }
    if role.IsSystem {
        return errors.New("系统内置角色不可删除")
    }
    
    // 3. 开启事务删除
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 删除角色菜单关联
        tx.Where("role_id = ?", roleId).Delete(&model.SRoleMenu{})
        
        // 删除角色继承关系
        tx.Where("role_id = ? OR parent_id = ?", roleId, roleId).Delete(&model.SRoleInherit{})
        
        // 删除 Casbin 策略
        s.casbinService.DeleteAllPoliciesForRole(ctx, role.RoleKey)
        
        // 删除角色
        return tx.Delete(&model.Role{}, roleId).Error
    })
}
```

### 11.4 安全相关问题

#### Q9: 如何防止权限提升攻击？

**A**: 多层防护。

```go
// 1. 在Service层检查操作权限
func (s *RoleService) AssignRoleToUser(ctx context.Context, userId, roleId, orgId int64) error {
    // 获取当前操作用户
    currentUserId := ctx.Value("userId").(int64)
    
    // 获取当前用户的角色
    currentRoles, _ := s.GetUserRoles(ctx, currentUserId)
    
    // 获取要分配的角色
    targetRole, _ := s.GetById(ctx, roleId)
    
    // 检查：不能分配比自己权限更高的角色
    for _, currentRole := range currentRoles {
        if currentRole.Sort >= targetRole.Sort {
            // 当前用户有足够权限
            goto ALLOWED
        }
    }
    return errors.New("无权分配该角色")
    
ALLOWED:
    // 执行分配逻辑
    ...
}

// 2. 在Controller层验证请求参数
func (c *RoleController) AssignRoleToUser(ctx *gin.Context) {
    var req request.AssignRoleRequest
    if err := ctx.ShouldBindJSON(&req); err != nil {
        response.BadRequest(ctx, "参数错误")
        return
    }
    
    // 验证：不能给自己分配角色
    currentUserId, _ := c.base.GetUserId(ctx)
    if req.UserId == currentUserId {
        response.BadRequest(ctx, "不能给自己分配角色")
        return
    }
    
    // 验证：目标用户必须在同一组织
    targetUser, _ := c.userService.GetById(ctx.Request.Context(), req.UserId)
    currentUser, _ := c.userService.GetById(ctx.Request.Context(), currentUserId)
    if targetUser.OrgId != currentUser.OrgId {
        response.Forbidden(ctx, "无权操作其他组织的用户")
        return
    }
    
    ...
}
```

#### Q10: 如何审计权限变更？

**A**: 记录操作日志。

```go
// 1. 定义操作日志模型
type OperLog struct {
    ID          int64
    UserId      int64
    UserName    string
    OrgId       int64
    Module      string  // 模块：role, user, menu
    Operation   string  // 操作：create, update, delete, assign
    Content     string  // 操作内容
    IP          string
    CreatedTime time.Time
}

// 2. 在关键操作中记录日志
func (s *RoleService) AssignRoleToUser(ctx context.Context, userId, roleId, orgId int64) error {
    // 执行分配
    err := s.casbinService.AddRoleForUser(ctx, userId, roleKey, orgId)
    if err != nil {
        return err
    }
    
    // 记录操作日志
    currentUserId := ctx.Value("userId").(int64)
    s.operLogService.Create(ctx, &OperLog{
        UserId:    currentUserId,
        OrgId:     orgId,
        Module:    "role",
        Operation: "assign",
        Content:   fmt.Sprintf("为用户%d分配角色%s", userId, roleKey),
        IP:        ctx.Value("clientIP").(string),
    })
    
    return nil
}
```

---

## 十二、总结

### 12.1 架构特点

本系统采用 **RBAC + Casbin + 多租户隔离** 的权限管理架构，具有以下特点：

1. **灵活强大**：支持通配符权限、角色继承、多租户隔离
2. **清晰分层**：Controller-Service-Domain分层明确，职责清晰
3. **充血模型**：领域逻辑封装在模型内，符合DDD原则
4. **高性能**：支持缓存优化，性能优异
5. **易于维护**：代码结构清晰，易于理解和维护
6. **安全可靠**：多层权限检查，防止权限提升攻击

### 12.2 核心组件

| 组件 | 职责 | 关键文件 |
|------|------|---------|
| Casbin引擎 | 权限验证核心 | cmd/api/casbin_model.conf |
| CasbinService | 权限管理服务 | internal/service/casbin.go |
| Auth中间件 | 用户认证 | internal/middleware/auth.go |
| Permission中间件 | 权限检查 | internal/middleware/permission.go |
| RoleService | 角色管理 | internal/service/role.go |
| MenuService | 菜单管理 | internal/service/menu.go |
| 领域模型 | 数据和业务逻辑 | internal/domain/model/ |

### 12.3 数据流转

```
用户请求
  ↓
Auth中间件（认证）
  ↓
Permission中间件（权限检查）
  ↓
Controller（参数验证）
  ↓
Service（业务逻辑）
  ↓
Domain（数据操作）
  ↓
数据库
```

### 12.4 关键表关系

```
s_user (用户)
  ├─ org_id → s_org (组织)
  └─ s_user_role → s_role (角色)
                     ├─ s_role_menu → s_menu (菜单)
                     ├─ s_role_inherit (角色继承)
                     └─ casbin_rule (Casbin策略)
```

### 12.5 使用建议

1. **权限粒度**：建议使用模块级（user.*）和操作级（user.create）两种粒度
2. **角色设计**：建议3-5层角色层次，不要过于复杂
3. **菜单结构**：建议使用目录-菜单-按钮三级结构
4. **性能优化**：对于高频查询，建议使用Redis缓存
5. **安全审计**：建议记录所有权限变更操作日志

---

## 附录

### A. 相关文档

- [Casbin官方文档](https://casbin.org/docs/zh-CN/overview)
- [GORM文档](https://gorm.io/zh_CN/docs/)
- [Gin框架文档](https://gin-gonic.com/zh-cn/docs/)
- [简化版RBAC方案](./02-架构设计/简化版RBAC方案.md)

### B. 数据库脚本

- 表结构：`scripts/sql/schema.sql`
- 初始数据：`scripts/sql/init_data.sql`

### C. 配置文件

- Casbin模型：`cmd/api/casbin_model.conf`
- 应用配置：`conf.dev.yaml`

### D. 关键代码位置

```
internal/
├── controller/          # 控制器层
│   ├── user.go         # 用户控制器
│   ├── role.go         # 角色控制器
│   └── menu.go         # 菜单控制器
├── service/            # 服务层
│   ├── casbin.go       # Casbin服务
│   ├── role.go         # 角色服务
│   └── menu.go         # 菜单服务
├── middleware/         # 中间件层
│   ├── auth.go         # 认证中间件
│   └── permission.go   # 权限中间件
├── domain/model/       # 领域模型层
│   ├── s_user.go       # 用户模型
│   ├── s_role.go       # 角色模型
│   └── s_menu.go       # 菜单模型
├── router/             # 路由层
│   ├── user.go         # 用户路由
│   ├── role.go         # 角色路由
│   └── menu.go         # 菜单路由
└── constants/          # 常量定义
    └── permission.go   # 权限常量
```

---

**文档版本**: v1.0  
**最后更新**: 2025-12-29  
**维护者**: 开发团队
