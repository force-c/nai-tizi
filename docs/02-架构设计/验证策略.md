# 验证策略设计指南

## 核心原则

**将验证分为两类：**
1. **不变规则（Invariants）** - 放在 Model 中
2. **场景规则（Contextual Rules）** - 放在 Service 或 Validator 中

## 实践方案

### 方案 A：Model + Service 分层验证（推荐）

#### 1. Model 层 - 只验证不变规则

```go
package model

import "errors"

type Role struct {
    RoleId   int64  `json:"roleId"`
    RoleKey  string `json:"roleKey"`
    RoleName string `json:"roleName"`
    Status   string `json:"status"`
}

// Validate 验证领域不变规则（无论什么场景都必须满足）
func (r *Role) Validate() error {
    // 这些规则在任何场景下都必须满足
    if r.RoleKey == "" {
        return errors.New("角色标识不能为空")
    }
    if len(r.RoleKey) > 50 {
        return errors.New("角色标识长度不能超过50")
    }
    if r.RoleName == "" {
        return errors.New("角色名称不能为空")
    }
    if r.Status != "0" && r.Status != "1" {
        return errors.New("状态值无效")
    }
    return nil
}

// 业务规则判断（领域逻辑）
func (r *Role) CanDelete() error {
    if r.IsSystem {
        return errors.New("系统角色不能删除")
    }
    return nil
}

func (r *Role) IsActive() bool {
    return r.Status == "0"
}
```

#### 2. Service 层 - 验证场景规则

```go
package service

import (
    "context"
    "errors"
    "fmt"
)

type roleService struct {
    db *gorm.DB
}

// Create 创建角色
func (s *roleService) Create(ctx context.Context, role *model.Role) error {
    // 1. 场景规则：创建时 ID 必须为空
    if role.RoleId != 0 {
        return errors.New("创建角色时不能指定 ID")
    }

    // 2. 验证领域不变规则（Model 负责）
    if err := role.Validate(); err != nil {
        return err
    }

    // 3. 场景规则：检查唯一性（需要数据库查询）
    exists, err := new(model.Role).ExistsByRoleKey(s.db, role.RoleKey)
    if err != nil {
        return fmt.Errorf("检查角色标识失败: %w", err)
    }
    if exists {
        return fmt.Errorf("角色标识已存在: %s", role.RoleKey)
    }

    // 4. 执行创建
    return role.Create(s.db)
}

// Update 更新角色
func (s *roleService) Update(ctx context.Context, role *model.Role) error {
    // 1. 场景规则：更新时 ID 必须不为空
    if role.RoleId == 0 {
        return errors.New("更新角色时必须指定 ID")
    }

    // 2. 验证领域不变规则
    if err := role.Validate(); err != nil {
        return err
    }

    // 3. 场景规则：检查角色是否存在
    oldRole, err := new(model.Role).FindByID(s.db, role.RoleId)
    if err != nil {
        return fmt.Errorf("角色不存在: %w", err)
    }

    // 4. 场景规则：系统角色不能修改标识
    if oldRole.IsSystem && role.RoleKey != oldRole.RoleKey {
        return errors.New("系统角色不能修改角色标识")
    }

    // 5. 执行更新
    return role.Update(s.db)
}

// Delete 删除角色
func (s *roleService) Delete(ctx context.Context, roleId int64) error {
    // 1. 场景规则：ID 必须不为空
    if roleId == 0 {
        return errors.New("角色 ID 不能为空")
    }

    // 2. 查询角色
    role, err := new(model.Role).FindByID(s.db, roleId)
    if err != nil {
        return fmt.Errorf("角色不存在: %w", err)
    }

    // 3. 领域规则：检查是否可以删除（Model 负责）
    if err := role.CanDelete(); err != nil {
        return err
    }

    // 4. 场景规则：检查是否有用户使用（需要关联查询）
    var userCount int64
    if err := s.db.Model(&model.SUserRole{}).
        Where("role_id = ?", roleId).
        Count(&userCount).Error; err != nil {
        return fmt.Errorf("检查用户角色关联失败: %w", err)
    }
    if userCount > 0 {
        return fmt.Errorf("该角色已分配给 %d 个用户，不能删除", userCount)
    }

    // 5. 执行删除
    return role.Delete(s.db)
}
```

### 方案 B：使用独立的 Validator（适合复杂场景）

#### 1. 定义验证器

```go
package validator

import (
    "errors"
    "github.com/force-c/nai-tizi/internal/domain/model"
    "gorm.io/gorm"
)

// RoleValidator 角色验证器
type RoleValidator struct {
    db *gorm.DB
}

func NewRoleValidator(db *gorm.DB) *RoleValidator {
    return &RoleValidator{db: db}
}

// ValidateForCreate 验证创建场景
func (v *RoleValidator) ValidateForCreate(role *model.Role) error {
    // 1. 场景规则
    if role.RoleId != 0 {
        return errors.New("创建角色时不能指定 ID")
    }

    // 2. 领域不变规则
    if err := role.Validate(); err != nil {
        return err
    }

    // 3. 唯一性检查
    exists, err := new(model.Role).ExistsByRoleKey(v.db, role.RoleKey)
    if err != nil {
        return err
    }
    if exists {
        return errors.New("角色标识已存在")
    }

    return nil
}

// ValidateForUpdate 验证更新场景
func (v *RoleValidator) ValidateForUpdate(role *model.Role) error {
    // 1. 场景规则
    if role.RoleId == 0 {
        return errors.New("更新角色时必须指定 ID")
    }

    // 2. 领域不变规则
    if err := role.Validate(); err != nil {
        return err
    }

    // 3. 检查角色是否存在
    oldRole, err := new(model.Role).FindByID(v.db, role.RoleId)
    if err != nil {
        return errors.New("角色不存在")
    }

    // 4. 系统角色特殊规则
    if oldRole.IsSystem && role.RoleKey != oldRole.RoleKey {
        return errors.New("系统角色不能修改角色标识")
    }

    return nil
}

// ValidateForDelete 验证删除场景
func (v *RoleValidator) ValidateForDelete(roleId int64) (*model.Role, error) {
    // 1. 场景规则
    if roleId == 0 {
        return nil, errors.New("角色 ID 不能为空")
    }

    // 2. 查询角色
    role, err := new(model.Role).FindByID(v.db, roleId)
    if err != nil {
        return nil, errors.New("角色不存在")
    }

    // 3. 领域规则
    if err := role.CanDelete(); err != nil {
        return nil, err
    }

    // 4. 关联检查
    var userCount int64
    if err := v.db.Model(&model.SUserRole{}).
        Where("role_id = ?", roleId).
        Count(&userCount).Error; err != nil {
        return nil, err
    }
    if userCount > 0 {
        return nil, errors.New("该角色已分配给用户，不能删除")
    }

    return role, nil
}
```

#### 2. Service 使用 Validator

```go
package service

type roleService struct {
    db        *gorm.DB
    validator *validator.RoleValidator
}

func NewRoleService(db *gorm.DB) RoleService {
    return &roleService{
        db:        db,
        validator: validator.NewRoleValidator(db),
    }
}

// Create 创建角色
func (s *roleService) Create(ctx context.Context, role *model.Role) error {
    // 使用 Validator 验证
    if err := s.validator.ValidateForCreate(role); err != nil {
        return err
    }

    // 执行创建
    return role.Create(s.db)
}

// Update 更新角色
func (s *roleService) Update(ctx context.Context, role *model.Role) error {
    // 使用 Validator 验证
    if err := s.validator.ValidateForUpdate(role); err != nil {
        return err
    }

    // 执行更新
    return role.Update(s.db)
}

// Delete 删除角色
func (s *roleService) Delete(ctx context.Context, roleId int64) error {
    // 使用 Validator 验证（返回验证后的角色对象）
    role, err := s.validator.ValidateForDelete(roleId)
    if err != nil {
        return err
    }

    // 执行删除
    return role.Delete(s.db)
}
```

### 方案 C：使用 Go Validator 库（适合简单场景）

```go
package request

import "github.com/go-playground/validator/v10"

// CreateRoleRequest 创建角色请求
type CreateRoleRequest struct {
    RoleKey  string `json:"roleKey" validate:"required,max=50"`
    RoleName string `json:"roleName" validate:"required,max=100"`
    Status   string `json:"status" validate:"required,oneof=0 1"`
}

// UpdateRoleRequest 更新角色请求
type UpdateRoleRequest struct {
    RoleId   int64  `json:"roleId" validate:"required,gt=0"`  // 必须大于0
    RoleKey  string `json:"roleKey" validate:"required,max=50"`
    RoleName string `json:"roleName" validate:"required,max=100"`
    Status   string `json:"status" validate:"required,oneof=0 1"`
}

// Controller 中使用
func (c *RoleController) CreateRole(ctx *gin.Context) {
    var req request.CreateRoleRequest
    if err := ctx.ShouldBindJSON(&req); err != nil {
        // Gin 会自动使用 validator 验证
        response.BadRequest(ctx, "参数错误: "+err.Error())
        return
    }
    // ... 转换为 Model 并调用 Service
}
```

## 推荐实践

### 验证规则分类表

| 验证类型 | 放置位置 | 示例 |
|---------|---------|------|
| **格式验证** | Request DTO + Gin Validator | 必填、长度、格式 |
| **领域不变规则** | Model.Validate() | 状态值范围、业务约束 |
| **场景规则** | Service 或 Validator | ID 是否为空、是否存在 |
| **关联规则** | Service | 外键检查、关联数据检查 |
| **业务规则** | Model 方法 | CanDelete(), IsActive() |

### 完整示例

```go
// ============ 1. Request DTO（格式验证）============
package request

type CreateRoleRequest struct {
    RoleKey  string `json:"roleKey" binding:"required,max=50"`
    RoleName string `json:"roleName" binding:"required,max=100"`
    Status   string `json:"status" binding:"required,oneof=0 1"`
}

type UpdateRoleRequest struct {
    RoleId   int64  `json:"roleId" binding:"required,gt=0"`
    RoleKey  string `json:"roleKey" binding:"required,max=50"`
    RoleName string `json:"roleName" binding:"required,max=100"`
    Status   string `json:"status" binding:"required,oneof=0 1"`
}

// ============ 2. Model（领域不变规则 + 业务规则）============
package model

type Role struct {
    RoleId   int64
    RoleKey  string
    RoleName string
    Status   string
    IsSystem bool
}

// Validate 领域不变规则（任何场景都必须满足）
func (r *Role) Validate() error {
    if r.RoleKey == "" {
        return errors.New("角色标识不能为空")
    }
    if r.RoleName == "" {
        return errors.New("角色名称不能为空")
    }
    if r.Status != "0" && r.Status != "1" {
        return errors.New("状态值无效")
    }
    return nil
}

// CanDelete 业务规则
func (r *Role) CanDelete() error {
    if r.IsSystem {
        return errors.New("系统角色不能删除")
    }
    return nil
}

// ============ 3. Service（场景规则 + 业务编排）============
package service

type roleService struct {
    db *gorm.DB
}

func (s *roleService) Create(ctx context.Context, role *model.Role) error {
    // 场景规则：创建时 ID 必须为空
    if role.RoleId != 0 {
        return errors.New("创建时不能指定 ID")
    }

    // 领域不变规则
    if err := role.Validate(); err != nil {
        return err
    }

    // 场景规则：唯一性检查
    exists, _ := new(model.Role).ExistsByRoleKey(s.db, role.RoleKey)
    if exists {
        return errors.New("角色标识已存在")
    }

    return role.Create(s.db)
}

func (s *roleService) Update(ctx context.Context, role *model.Role) error {
    // 场景规则：更新时 ID 必须不为空
    if role.RoleId == 0 {
        return errors.New("更新时必须指定 ID")
    }

    // 领域不变规则
    if err := role.Validate(); err != nil {
        return err
    }

    // 场景规则：检查是否存在
    oldRole, err := new(model.Role).FindByID(s.db, role.RoleId)
    if err != nil {
        return errors.New("角色不存在")
    }

    // 场景规则：系统角色特殊限制
    if oldRole.IsSystem && role.RoleKey != oldRole.RoleKey {
        return errors.New("系统角色不能修改标识")
    }

    return role.Update(s.db)
}
```

## 总结

### 推荐方案：**方案 A（Model + Service 分层验证）**

**优点：**
- ✅ 职责清晰：Model 管不变规则，Service 管场景规则
- ✅ 易于理解和维护
- ✅ 不需要额外的 Validator 层
- ✅ 符合单一职责原则

**规则：**
1. **Request DTO** - 格式验证（必填、长度、类型）
2. **Model.Validate()** - 领域不变规则（任何场景都要满足）
3. **Model 业务方法** - 领域逻辑判断（CanDelete, IsActive）
4. **Service** - 场景规则（ID 检查、唯一性、关联检查）

这样既保持了 Model 的充血特性，又避免了方法名混乱的问题！
