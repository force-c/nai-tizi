# 数据模型规范化方案

## 一、当前问题分析

### 1. 表名和模型命名不一致

#### 问题表：
- ❌ `sys_user` → 应改为 `s_user`
- ❌ `sys_client` → 应改为 `s_client`
- ❌ `sys_dict_data` → 应改为 `s_dict_data`
- ❌ `sys_login_log` → 应改为 `s_login_log`
- ❌ `sys_oper_log` → 应改为 `s_oper_log`

#### 对应模型：
- ❌ `SysUser` → 应改为 `SUser`
- ❌ `SysClient` → 应改为 `SClient`
- ❌ `SysDictData` → 应改为 `SDictData`

### 2. ID 字段重复问题

#### 问题模型：
所有使用 `gorm.Model` 的结构体都存在 ID 重复问题：

```go
type SMenu struct {
    MenuId int64 `gorm:"column:menu_id;primaryKey;autoIncrement"`
    // ... 其他字段
    gorm.Model  // 这里会自动添加 ID uint 字段，导致重复
}
```

**gorm.Model 包含的字段：**
```go
type Model struct {
    ID        uint           `gorm:"primaryKey"`
    CreatedAt time.Time
    UpdatedAt time.Time
    DeletedAt gorm.DeletedAt `gorm:"index"`
}
```

**解决方案：**
不使用 `gorm.Model`，手动添加需要的字段：

```go
type SMenu struct {
    MenuId    int64     `gorm:"column:menu_id;primaryKey;autoIncrement"`
    // ... 业务字段
    CreateBy  int64     `gorm:"column:create_by"`
    UpdateBy  int64     `gorm:"column:update_by"`
    CreatedAt time.Time `gorm:"column:create_time;autoCreateTime"`
    UpdatedAt time.Time `gorm:"column:update_time;autoUpdateTime"`
    DeletedAt gorm.DeletedAt `gorm:"column:deleted_at;index"`
}
```

### 3. 废弃字段问题

#### sys_user 表：
- ❌ `dept_id` 字段应移除（已使用 `s_org` 表替代部门概念）

### 4. 服务层表名引用错误

#### internal/service/s_role.go：
```go
// 错误：使用了 sys_role, sys_user_role, sys_menu
err := s.db.Table("sys_role r").
    Joins("INNER JOIN sys_user_role ur ON r.role_id = ur.role_id").
    // ...

// 应改为：
err := s.db.Table("s_role r").
    Joins("INNER JOIN s_user_role ur ON r.role_id = ur.role_id").
    // ...
```

---

## 二、用户-组织-角色关系主流方案

### 方案概述

采用 **多租户 + RBAC + 组织树** 的混合模型：

```
用户 (s_user)
  ↓
用户组织关系 (s_user_org) - 一个用户可以属于多个组织
  ↓
组织 (s_org) - 树形结构，支持公司/部门/小组
  ↓
用户角色关系 (s_user_role) - 用户在不同组织中可以有不同角色
  ↓
角色 (s_role) - 角色定义
  ↓
角色权限关系 (s_role_menu) - 角色拥有的权限
  ↓
权限/菜单 (s_menu) - 权限定义
```

### 核心表结构

#### 1. 用户表 (s_user)
```sql
CREATE TABLE s_user (
    user_id BIGSERIAL PRIMARY KEY,
    user_name VARCHAR(50) NOT NULL UNIQUE,  -- 登录账号
    nick_name VARCHAR(50),                  -- 昵称
    email VARCHAR(100),
    phonenumber VARCHAR(20),
    password VARCHAR(255),
    avatar VARCHAR(500),
    status CHAR(1) DEFAULT '0',             -- 0正常 1停用
    user_type VARCHAR(20) DEFAULT 'system', -- system/wechat/app
    open_id VARCHAR(100),                   -- 微信OpenID
    union_id VARCHAR(100),                  -- 微信UnionID
    login_ip VARCHAR(50),
    login_date BIGINT,
    remark VARCHAR(500),
    create_by BIGINT,
    update_by BIGINT,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);
```

**说明：**
- 移除 `dept_id` 字段
- 用户不直接关联组织，通过 `s_user_org` 中间表关联

#### 2. 用户组织关系表 (s_user_org)
```sql
CREATE TABLE s_user_org (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,                -- 用户ID
    org_id BIGINT NOT NULL,                 -- 组织ID
    is_primary BOOLEAN DEFAULT FALSE,       -- 是否主组织
    position VARCHAR(100),                  -- 职位
    sort_order INT DEFAULT 0,               -- 排序
    create_by BIGINT,
    update_by BIGINT,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, org_id)
);

CREATE INDEX idx_user_org_user ON s_user_org(user_id);
CREATE INDEX idx_user_org_org ON s_user_org(org_id);
```

**说明：**
- 支持一个用户属于多个组织
- `is_primary` 标识用户的主组织
- `position` 记录用户在该组织的职位

#### 3. 组织表 (s_org) - 已存在，保持不变
```sql
CREATE TABLE s_org (
    org_id BIGSERIAL PRIMARY KEY,
    parent_id BIGINT DEFAULT 0,             -- 父组织ID
    ancestors VARCHAR(500),                 -- 祖级列表
    org_name VARCHAR(100) NOT NULL,
    org_code VARCHAR(100) UNIQUE,
    org_type VARCHAR(20) DEFAULT 'company', -- company/dept/group
    leader VARCHAR(50),
    phone VARCHAR(20),
    email VARCHAR(100),
    status CHAR(1) DEFAULT '0',
    order_num INT DEFAULT 0,
    remark VARCHAR(500),
    create_by BIGINT,
    update_by BIGINT,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 4. 用户角色关系表 (s_user_role) - 已存在，保持不变
```sql
CREATE TABLE s_user_role (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    role_id BIGINT NOT NULL,
    org_id BIGINT NOT NULL,                 -- 在哪个组织中拥有该角色
    create_by BIGINT,
    update_by BIGINT,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, role_id, org_id)
);
```

**说明：**
- 用户在不同组织中可以有不同角色
- 例如：张三在总公司是普通员工，在技术部是部门经理

### 关系图

```
┌─────────────┐
│   s_user    │ 用户基础信息
│  (用户表)    │
└──────┬──────┘
       │
       │ 1:N
       ↓
┌─────────────┐
│ s_user_org  │ 用户属于哪些组织
│(用户组织表)  │
└──────┬──────┘
       │
       │ N:1
       ↓
┌─────────────┐
│   s_org     │ 组织信息（树形）
│  (组织表)    │
└─────────────┘

┌─────────────┐
│   s_user    │
└──────┬──────┘
       │
       │ 1:N
       ↓
┌─────────────┐
│ s_user_role │ 用户在某组织中的角色
│(用户角色表)  │
└──────┬──────┘
       │
       │ N:1
       ↓
┌─────────────┐
│   s_role    │ 角色定义
│  (角色表)    │
└──────┬──────┘
       │
       │ 1:N
       ↓
┌─────────────┐
│ s_role_menu │ 角色拥有的权限
│(角色权限表)  │
└──────┬──────┘
       │
       │ N:1
       ↓
┌─────────────┐
│   s_menu    │ 权限/菜单定义
│ (权限表)     │
└─────────────┘
```

### 典型场景示例

#### 场景1：查询用户在某组织的权限
```sql
-- 1. 查询用户在组织1中的所有角色
SELECT r.* 
FROM s_role r
INNER JOIN s_user_role ur ON r.role_id = ur.role_id
WHERE ur.user_id = 1001 AND ur.org_id = 1;

-- 2. 查询用户在组织1中的所有权限
SELECT DISTINCT m.*
FROM s_menu m
INNER JOIN s_role_menu rm ON m.menu_id = rm.menu_id
INNER JOIN s_user_role ur ON rm.role_id = ur.role_id
WHERE ur.user_id = 1001 AND ur.org_id = 1 AND m.status = '0';
```

#### 场景2：查询用户所属的所有组织
```sql
SELECT o.*
FROM s_org o
INNER JOIN s_user_org uo ON o.org_id = uo.org_id
WHERE uo.user_id = 1001
ORDER BY uo.is_primary DESC, uo.sort_order ASC;
```

#### 场景3：查询组织下的所有用户
```sql
SELECT u.*, uo.position, uo.is_primary
FROM s_user u
INNER JOIN s_user_org uo ON u.user_id = uo.user_id
WHERE uo.org_id = 1
ORDER BY uo.sort_order ASC;
```

#### 场景4：查询用户在主组织的角色
```sql
SELECT r.*
FROM s_role r
INNER JOIN s_user_role ur ON r.role_id = ur.role_id
INNER JOIN s_user_org uo ON ur.org_id = uo.org_id AND ur.user_id = uo.user_id
WHERE uo.user_id = 1001 AND uo.is_primary = TRUE;
```

---

## 三、优势分析

### 1. 灵活性
- ✅ 支持用户属于多个组织
- ✅ 支持用户在不同组织有不同角色
- ✅ 支持组织树形结构（公司-部门-小组）

### 2. 扩展性
- ✅ 易于添加新的组织类型
- ✅ 易于实现跨组织协作
- ✅ 易于实现数据权限隔离

### 3. 性能
- ✅ 通过索引优化查询性能
- ✅ 避免复杂的递归查询
- ✅ 支持缓存优化

### 4. 安全性
- ✅ 多租户隔离（通过 org_id）
- ✅ 细粒度权限控制
- ✅ 支持 Casbin 策略引擎

---

## 四、与 Casbin 集成

### Casbin 策略示例

```
# 用户角色关系（g 策略）
g, user::1001, role::admin, org::1
g, user::1001, role::manager, org::2

# 角色权限（p 策略）
p, role::admin, org::1, *, *
p, role::manager, org::2, user.*, write
```

### 权限检查流程

1. 用户登录时，获取用户所属的所有组织
2. 根据当前操作的组织上下文，查询用户在该组织的角色
3. 使用 Casbin 检查角色是否有权限执行操作
4. 返回权限检查结果

---

## 五、实施建议

### 阶段1：表结构调整
1. 创建 `s_user_org` 表
2. 重命名所有 `sys_` 表为 `s_` 前缀
3. 移除 `sys_user.dept_id` 字段
4. 修复所有模型的 ID 重复问题

### 阶段2：代码调整
1. 更新所有模型结构体
2. 更新所有服务层的表名引用
3. 添加用户-组织关系管理接口
4. 更新权限检查逻辑

### 阶段3：数据迁移
1. 将现有 `dept_id` 数据迁移到 `s_user_org`
2. 验证数据完整性
3. 清理废弃字段

### 阶段4：测试验证
1. 单元测试
2. 集成测试
3. 性能测试
4. 安全测试
