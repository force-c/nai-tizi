# éªŒè¯ç ç³»ç»Ÿè®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æè¿°äº†ä¸€ä¸ªåŸºäºæ¥å£å®ç°çš„çµæ´»éªŒè¯ç ç³»ç»Ÿï¼Œæ”¯æŒå¤šç§éªŒè¯ç ç±»å‹ï¼Œå¯é€šè¿‡é…ç½®çµæ´»æ§åˆ¶å¯ç”¨/ç¦ç”¨ã€‚

**è®¾è®¡æ—¶é—´ï¼š** 2026-01-12  
**è®¾è®¡åŸåˆ™ï¼š** æ¥å£æŠ½è±¡ã€ç­–ç•¥æ¨¡å¼ã€é…ç½®é©±åŠ¨

---

## ğŸ¯ è®¾è®¡ç›®æ ‡

1. **çµæ´»æ€§**ï¼šæ”¯æŒå¤šç§éªŒè¯ç ç±»å‹ï¼ˆå›¾å½¢ã€çŸ­ä¿¡ã€é‚®ç®±ç­‰ï¼‰
2. **å¯æ‰©å±•æ€§**ï¼šæ–°å¢éªŒè¯ç ç±»å‹æ— éœ€ä¿®æ”¹ç°æœ‰ä»£ç 
3. **å¯é…ç½®æ€§**ï¼šé€šè¿‡é…ç½®æ–‡ä»¶æ§åˆ¶å¯ç”¨/ç¦ç”¨
4. **ç»Ÿä¸€æ¥å£**ï¼šæ‰€æœ‰éªŒè¯ç ç±»å‹å®ç°ç»Ÿä¸€æ¥å£
5. **æ˜“äºæµ‹è¯•**ï¼šæ¥å£è®¾è®¡ä¾¿äºå•å…ƒæµ‹è¯•å’Œ Mock

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ ¸å¿ƒæ¥å£å®šä¹‰

```go
// CaptchaProvider éªŒè¯ç æä¾›è€…æ¥å£
type CaptchaProvider interface {
    // GetType è·å–éªŒè¯ç ç±»å‹
    GetType() CaptchaType
    
    // Generate ç”ŸæˆéªŒè¯ç 
    // è¿”å›ï¼šéªŒè¯ç IDã€éªŒè¯ç æ•°æ®ï¼ˆå¦‚å›¾ç‰‡base64ã€çŸ­ä¿¡å†…å®¹ç­‰ï¼‰ã€é”™è¯¯
    Generate(ctx context.Context, target string) (*CaptchaData, error)
    
    // Verify éªŒè¯éªŒè¯ç 
    // å‚æ•°ï¼šéªŒè¯ç IDã€ç”¨æˆ·è¾“å…¥çš„éªŒè¯ç 
    Verify(ctx context.Context, captchaID string, code string) error
    
    // IsEnabled æ˜¯å¦å¯ç”¨
    IsEnabled() bool
}

// CaptchaType éªŒè¯ç ç±»å‹
type CaptchaType string

const (
    CaptchaTypeImage CaptchaType = "image" // å›¾å½¢éªŒè¯ç 
    CaptchaTypeSMS   CaptchaType = "sms"   // çŸ­ä¿¡éªŒè¯ç 
    CaptchaTypeEmail CaptchaType = "email" // é‚®ç®±éªŒè¯ç 
)

// CaptchaData éªŒè¯ç æ•°æ®
type CaptchaData struct {
    ID       string      `json:"id"`       // éªŒè¯ç ID
    Type     CaptchaType `json:"type"`     // éªŒè¯ç ç±»å‹
    Data     interface{} `json:"data"`     // éªŒè¯ç æ•°æ®ï¼ˆå›¾ç‰‡base64ã€çŸ­ä¿¡å†…å®¹ç­‰ï¼‰
    ExpireAt time.Time   `json:"expireAt"` // è¿‡æœŸæ—¶é—´
}
```

### éªŒè¯ç ç®¡ç†å™¨

```go
// CaptchaManager éªŒè¯ç ç®¡ç†å™¨
type CaptchaManager struct {
    providers map[CaptchaType]CaptchaProvider
    config    *CaptchaConfig
}

// CaptchaConfig éªŒè¯ç é…ç½®
type CaptchaConfig struct {
    Image struct {
        Enabled bool   `yaml:"enabled"` // æ˜¯å¦å¯ç”¨å›¾å½¢éªŒè¯ç 
        Length  int    `yaml:"length"`  // éªŒè¯ç é•¿åº¦
        Width   int    `yaml:"width"`   // å›¾ç‰‡å®½åº¦
        Height  int    `yaml:"height"`  // å›¾ç‰‡é«˜åº¦
        Expire  int    `yaml:"expire"`  // è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰
    } `yaml:"image"`
    
    SMS struct {
        Enabled  bool   `yaml:"enabled"`  // æ˜¯å¦å¯ç”¨çŸ­ä¿¡éªŒè¯ç 
        Length   int    `yaml:"length"`   // éªŒè¯ç é•¿åº¦
        Expire   int    `yaml:"expire"`   // è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰
        Template string `yaml:"template"` // çŸ­ä¿¡æ¨¡æ¿
        Provider string `yaml:"provider"` // çŸ­ä¿¡æœåŠ¡å•†ï¼ˆaliyun/tencentï¼‰
    } `yaml:"sms"`
    
    Email struct {
        Enabled  bool   `yaml:"enabled"`  // æ˜¯å¦å¯ç”¨é‚®ç®±éªŒè¯ç 
        Length   int    `yaml:"length"`   // éªŒè¯ç é•¿åº¦
        Expire   int    `yaml:"expire"`   // è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰
        Template string `yaml:"template"` // é‚®ä»¶æ¨¡æ¿
    } `yaml:"email"`
}

// NewCaptchaManager åˆ›å»ºéªŒè¯ç ç®¡ç†å™¨
func NewCaptchaManager(config *CaptchaConfig, redis *redis.Client) *CaptchaManager {
    manager := &CaptchaManager{
        providers: make(map[CaptchaType]CaptchaProvider),
        config:    config,
    }
    
    // æ³¨å†Œå›¾å½¢éªŒè¯ç æä¾›è€…
    if config.Image.Enabled {
        manager.RegisterProvider(NewImageCaptchaProvider(config, redis))
    }
    
    // æ³¨å†ŒçŸ­ä¿¡éªŒè¯ç æä¾›è€…
    if config.SMS.Enabled {
        manager.RegisterProvider(NewSMSCaptchaProvider(config, redis))
    }
    
    // æ³¨å†Œé‚®ç®±éªŒè¯ç æä¾›è€…
    if config.Email.Enabled {
        manager.RegisterProvider(NewEmailCaptchaProvider(config, redis))
    }
    
    return manager
}

// RegisterProvider æ³¨å†ŒéªŒè¯ç æä¾›è€…
func (m *CaptchaManager) RegisterProvider(provider CaptchaProvider) {
    m.providers[provider.GetType()] = provider
}

// GetProvider è·å–éªŒè¯ç æä¾›è€…
func (m *CaptchaManager) GetProvider(captchaType CaptchaType) (CaptchaProvider, error) {
    provider, ok := m.providers[captchaType]
    if !ok {
        return nil, fmt.Errorf("éªŒè¯ç ç±»å‹ %s æœªå¯ç”¨", captchaType)
    }
    return provider, nil
}

// Generate ç”ŸæˆéªŒè¯ç 
func (m *CaptchaManager) Generate(ctx context.Context, captchaType CaptchaType, target string) (*CaptchaData, error) {
    provider, err := m.GetProvider(captchaType)
    if err != nil {
        return nil, err
    }
    return provider.Generate(ctx, target)
}

// Verify éªŒè¯éªŒè¯ç 
func (m *CaptchaManager) Verify(ctx context.Context, captchaType CaptchaType, captchaID string, code string) error {
    provider, err := m.GetProvider(captchaType)
    if err != nil {
        return err
    }
    return provider.Verify(ctx, captchaID, code)
}

// GetEnabledTypes è·å–å·²å¯ç”¨çš„éªŒè¯ç ç±»å‹
func (m *CaptchaManager) GetEnabledTypes() []CaptchaType {
    types := make([]CaptchaType, 0, len(m.providers))
    for captchaType := range m.providers {
        types = append(types, captchaType)
    }
    return types
}
```

---

## ğŸ”§ å…·ä½“å®ç°

### 1. å›¾å½¢éªŒè¯ç å®ç°

```go
// ImageCaptchaProvider å›¾å½¢éªŒè¯ç æä¾›è€…
type ImageCaptchaProvider struct {
    config *CaptchaConfig
    redis  *redis.Client
}

func NewImageCaptchaProvider(config *CaptchaConfig, redis *redis.Client) *ImageCaptchaProvider {
    return &ImageCaptchaProvider{
        config: config,
        redis:  redis,
    }
}

func (p *ImageCaptchaProvider) GetType() CaptchaType {
    return CaptchaTypeImage
}

func (p *ImageCaptchaProvider) Generate(ctx context.Context, target string) (*CaptchaData, error) {
    // ç”ŸæˆéªŒè¯ç ID
    captchaID := uuid.New().String()
    
    // ç”ŸæˆéšæœºéªŒè¯ç 
    code := generateRandomCode(p.config.Image.Length)
    
    // ç”ŸæˆéªŒè¯ç å›¾ç‰‡ï¼ˆä½¿ç”¨ github.com/mojocn/base64Captchaï¼‰
    imageData, err := generateCaptchaImage(code, p.config.Image.Width, p.config.Image.Height)
    if err != nil {
        return nil, err
    }
    
    // å­˜å‚¨åˆ° Redis
    key := fmt.Sprintf("captcha:image:%s", captchaID)
    expire := time.Duration(p.config.Image.Expire) * time.Second
    if err := p.redis.Set(ctx, key, code, expire).Err(); err != nil {
        return nil, err
    }
    
    return &CaptchaData{
        ID:       captchaID,
        Type:     CaptchaTypeImage,
        Data:     imageData, // base64 ç¼–ç çš„å›¾ç‰‡
        ExpireAt: time.Now().Add(expire),
    }, nil
}

func (p *ImageCaptchaProvider) Verify(ctx context.Context, captchaID string, code string) error {
    key := fmt.Sprintf("captcha:image:%s", captchaID)
    
    // ä» Redis è·å–éªŒè¯ç 
    storedCode, err := p.redis.Get(ctx, key).Result()
    if err == redis.Nil {
        return errors.New("éªŒè¯ç å·²è¿‡æœŸæˆ–ä¸å­˜åœ¨")
    }
    if err != nil {
        return err
    }
    
    // éªŒè¯ååˆ é™¤ï¼ˆä¸€æ¬¡æ€§ä½¿ç”¨ï¼‰
    p.redis.Del(ctx, key)
    
    // ä¸åŒºåˆ†å¤§å°å†™æ¯”è¾ƒ
    if !strings.EqualFold(storedCode, code) {
        return errors.New("éªŒè¯ç é”™è¯¯")
    }
    
    return nil
}

func (p *ImageCaptchaProvider) IsEnabled() bool {
    return p.config.Image.Enabled
}
```

### 2. çŸ­ä¿¡éªŒè¯ç å®ç°

```go
// SMSCaptchaProvider çŸ­ä¿¡éªŒè¯ç æä¾›è€…
type SMSCaptchaProvider struct {
    config      *CaptchaConfig
    redis       *redis.Client
    smsProvider SMSProvider // çŸ­ä¿¡æœåŠ¡æä¾›è€…æ¥å£
}

// SMSProvider çŸ­ä¿¡æœåŠ¡æä¾›è€…æ¥å£
type SMSProvider interface {
    SendSMS(phone string, code string, template string) error
}

func NewSMSCaptchaProvider(config *CaptchaConfig, redis *redis.Client, smsProvider SMSProvider) *SMSCaptchaProvider {
    return &SMSCaptchaProvider{
        config:      config,
        redis:       redis,
        smsProvider: smsProvider,
    }
}

func (p *SMSCaptchaProvider) GetType() CaptchaType {
    return CaptchaTypeSMS
}

func (p *SMSCaptchaProvider) Generate(ctx context.Context, phone string) (*CaptchaData, error) {
    // éªŒè¯æ‰‹æœºå·æ ¼å¼
    if !isValidPhone(phone) {
        return nil, errors.New("æ‰‹æœºå·æ ¼å¼é”™è¯¯")
    }
    
    // æ£€æŸ¥å‘é€é¢‘ç‡é™åˆ¶ï¼ˆ60ç§’å†…åªèƒ½å‘é€ä¸€æ¬¡ï¼‰
    rateLimitKey := fmt.Sprintf("captcha:sms:ratelimit:%s", phone)
    exists, err := p.redis.Exists(ctx, rateLimitKey).Result()
    if err != nil {
        return nil, err
    }
    if exists > 0 {
        return nil, errors.New("å‘é€è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•")
    }
    
    // ç”ŸæˆéªŒè¯ç ID
    captchaID := uuid.New().String()
    
    // ç”Ÿæˆéšæœºæ•°å­—éªŒè¯ç 
    code := generateRandomDigits(p.config.SMS.Length)
    
    // å‘é€çŸ­ä¿¡
    if err := p.smsProvider.SendSMS(phone, code, p.config.SMS.Template); err != nil {
        return nil, fmt.Errorf("çŸ­ä¿¡å‘é€å¤±è´¥: %w", err)
    }
    
    // å­˜å‚¨åˆ° Redis
    key := fmt.Sprintf("captcha:sms:%s", captchaID)
    expire := time.Duration(p.config.SMS.Expire) * time.Second
    
    // å­˜å‚¨éªŒè¯ç ä¿¡æ¯ï¼ˆåŒ…å«æ‰‹æœºå·ï¼Œç”¨äºéªŒè¯æ—¶æ ¡éªŒï¼‰
    data := map[string]string{
        "code":  code,
        "phone": phone,
    }
    if err := p.redis.HSet(ctx, key, data).Err(); err != nil {
        return nil, err
    }
    if err := p.redis.Expire(ctx, key, expire).Err(); err != nil {
        return nil, err
    }
    
    // è®¾ç½®å‘é€é¢‘ç‡é™åˆ¶
    p.redis.Set(ctx, rateLimitKey, "1", 60*time.Second)
    
    return &CaptchaData{
        ID:       captchaID,
        Type:     CaptchaTypeSMS,
        Data:     map[string]interface{}{"phone": maskPhone(phone)}, // è¿”å›è„±æ•æ‰‹æœºå·
        ExpireAt: time.Now().Add(expire),
    }, nil
}

func (p *SMSCaptchaProvider) Verify(ctx context.Context, captchaID string, code string) error {
    key := fmt.Sprintf("captcha:sms:%s", captchaID)
    
    // ä» Redis è·å–éªŒè¯ç ä¿¡æ¯
    data, err := p.redis.HGetAll(ctx, key).Result()
    if err != nil {
        return err
    }
    if len(data) == 0 {
        return errors.New("éªŒè¯ç å·²è¿‡æœŸæˆ–ä¸å­˜åœ¨")
    }
    
    storedCode := data["code"]
    
    // éªŒè¯ååˆ é™¤ï¼ˆä¸€æ¬¡æ€§ä½¿ç”¨ï¼‰
    p.redis.Del(ctx, key)
    
    // æ¯”è¾ƒéªŒè¯ç 
    if storedCode != code {
        return errors.New("éªŒè¯ç é”™è¯¯")
    }
    
    return nil
}

func (p *SMSCaptchaProvider) IsEnabled() bool {
    return p.config.SMS.Enabled
}
```

### 3. é‚®ç®±éªŒè¯ç å®ç°

```go
// EmailCaptchaProvider é‚®ç®±éªŒè¯ç æä¾›è€…
type EmailCaptchaProvider struct {
    config        *CaptchaConfig
    redis         *redis.Client
    emailProvider EmailProvider // é‚®ä»¶æœåŠ¡æä¾›è€…æ¥å£
}

// EmailProvider é‚®ä»¶æœåŠ¡æä¾›è€…æ¥å£
type EmailProvider interface {
    SendEmail(email string, subject string, content string) error
}

func NewEmailCaptchaProvider(config *CaptchaConfig, redis *redis.Client, emailProvider EmailProvider) *EmailCaptchaProvider {
    return &EmailCaptchaProvider{
        config:        config,
        redis:         redis,
        emailProvider: emailProvider,
    }
}

func (p *EmailCaptchaProvider) GetType() CaptchaType {
    return CaptchaTypeEmail
}

func (p *EmailCaptchaProvider) Generate(ctx context.Context, email string) (*CaptchaData, error) {
    // éªŒè¯é‚®ç®±æ ¼å¼
    if !isValidEmail(email) {
        return nil, errors.New("é‚®ç®±æ ¼å¼é”™è¯¯")
    }
    
    // æ£€æŸ¥å‘é€é¢‘ç‡é™åˆ¶
    rateLimitKey := fmt.Sprintf("captcha:email:ratelimit:%s", email)
    exists, err := p.redis.Exists(ctx, rateLimitKey).Result()
    if err != nil {
        return nil, err
    }
    if exists > 0 {
        return nil, errors.New("å‘é€è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•")
    }
    
    // ç”ŸæˆéªŒè¯ç ID
    captchaID := uuid.New().String()
    
    // ç”Ÿæˆéšæœºæ•°å­—éªŒè¯ç 
    code := generateRandomDigits(p.config.Email.Length)
    
    // æ¸²æŸ“é‚®ä»¶å†…å®¹
    content := renderEmailTemplate(p.config.Email.Template, code)
    
    // å‘é€é‚®ä»¶
    if err := p.emailProvider.SendEmail(email, "éªŒè¯ç ", content); err != nil {
        return nil, fmt.Errorf("é‚®ä»¶å‘é€å¤±è´¥: %w", err)
    }
    
    // å­˜å‚¨åˆ° Redis
    key := fmt.Sprintf("captcha:email:%s", captchaID)
    expire := time.Duration(p.config.Email.Expire) * time.Second
    
    data := map[string]string{
        "code":  code,
        "email": email,
    }
    if err := p.redis.HSet(ctx, key, data).Err(); err != nil {
        return nil, err
    }
    if err := p.redis.Expire(ctx, key, expire).Err(); err != nil {
        return nil, err
    }
    
    // è®¾ç½®å‘é€é¢‘ç‡é™åˆ¶
    p.redis.Set(ctx, rateLimitKey, "1", 60*time.Second)
    
    return &CaptchaData{
        ID:       captchaID,
        Type:     CaptchaTypeEmail,
        Data:     map[string]interface{}{"email": maskEmail(email)},
        ExpireAt: time.Now().Add(expire),
    }, nil
}

func (p *EmailCaptchaProvider) Verify(ctx context.Context, captchaID string, code string) error {
    key := fmt.Sprintf("captcha:email:%s", captchaID)
    
    data, err := p.redis.HGetAll(ctx, key).Result()
    if err != nil {
        return err
    }
    if len(data) == 0 {
        return errors.New("éªŒè¯ç å·²è¿‡æœŸæˆ–ä¸å­˜åœ¨")
    }
    
    storedCode := data["code"]
    
    // éªŒè¯ååˆ é™¤
    p.redis.Del(ctx, key)
    
    if storedCode != code {
        return errors.New("éªŒè¯ç é”™è¯¯")
    }
    
    return nil
}

func (p *EmailCaptchaProvider) IsEnabled() bool {
    return p.config.Email.Enabled
}
```

---

## ğŸ“ é…ç½®æ–‡ä»¶ç¤ºä¾‹

### conf.yaml

```yaml
captcha:
  # å›¾å½¢éªŒè¯ç é…ç½®
  image:
    enabled: true      # æ˜¯å¦å¯ç”¨
    length: 4          # éªŒè¯ç é•¿åº¦
    width: 120         # å›¾ç‰‡å®½åº¦
    height: 40         # å›¾ç‰‡é«˜åº¦
    expire: 300        # è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰
  
  # çŸ­ä¿¡éªŒè¯ç é…ç½®
  sms:
    enabled: true      # æ˜¯å¦å¯ç”¨
    length: 6          # éªŒè¯ç é•¿åº¦
    expire: 300        # è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰
    template: "æ‚¨çš„éªŒè¯ç æ˜¯ï¼š{code}ï¼Œ{expire}åˆ†é’Ÿå†…æœ‰æ•ˆ"
    provider: "aliyun" # çŸ­ä¿¡æœåŠ¡å•†ï¼ˆaliyun/tencentï¼‰
  
  # é‚®ç®±éªŒè¯ç é…ç½®
  email:
    enabled: true      # æ˜¯å¦å¯ç”¨
    length: 6          # éªŒè¯ç é•¿åº¦
    expire: 300        # è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰
    template: "email_verification.html" # é‚®ä»¶æ¨¡æ¿æ–‡ä»¶
```

---

## ğŸ”Œ Controller å±‚ä½¿ç”¨

```go
// CaptchaController éªŒè¯ç æ§åˆ¶å™¨
type CaptchaController struct {
    captchaManager *CaptchaManager
}

// GenerateImageCaptcha ç”Ÿæˆå›¾å½¢éªŒè¯ç 
// @Summary ç”Ÿæˆå›¾å½¢éªŒè¯ç 
// @Tags éªŒè¯ç 
// @Accept json
// @Produce json
// @Success 200 {object} response.Response{data=CaptchaData}
// @Router /captcha/image [get]
func (c *CaptchaController) GenerateImageCaptcha(ctx *gin.Context) {
    data, err := c.captchaManager.Generate(ctx, CaptchaTypeImage, "")
    if err != nil {
        response.FailWithMessage(err.Error(), ctx)
        return
    }
    response.OkWithData(data, ctx)
}

// SendSMSCaptcha å‘é€çŸ­ä¿¡éªŒè¯ç 
// @Summary å‘é€çŸ­ä¿¡éªŒè¯ç 
// @Tags éªŒè¯ç 
// @Accept json
// @Produce json
// @Param request body SendSMSRequest true "æ‰‹æœºå·"
// @Success 200 {object} response.Response{data=CaptchaData}
// @Router /captcha/sms [post]
func (c *CaptchaController) SendSMSCaptcha(ctx *gin.Context) {
    var req SendSMSRequest
    if err := ctx.ShouldBindJSON(&req); err != nil {
        response.FailWithMessage(err.Error(), ctx)
        return
    }
    
    data, err := c.captchaManager.Generate(ctx, CaptchaTypeSMS, req.Phone)
    if err != nil {
        response.FailWithMessage(err.Error(), ctx)
        return
    }
    response.OkWithData(data, ctx)
}

// SendEmailCaptcha å‘é€é‚®ç®±éªŒè¯ç 
// @Summary å‘é€é‚®ç®±éªŒè¯ç 
// @Tags éªŒè¯ç 
// @Accept json
// @Produce json
// @Param request body SendEmailRequest true "é‚®ç®±"
// @Success 200 {object} response.Response{data=CaptchaData}
// @Router /captcha/email [post]
func (c *CaptchaController) SendEmailCaptcha(ctx *gin.Context) {
    var req SendEmailRequest
    if err := ctx.ShouldBindJSON(&req); err != nil {
        response.FailWithMessage(err.Error(), ctx)
        return
    }
    
    data, err := c.captchaManager.Generate(ctx, CaptchaTypeEmail, req.Email)
    if err != nil {
        response.FailWithMessage(err.Error(), ctx)
        return
    }
    response.OkWithData(data, ctx)
}

// GetEnabledTypes è·å–å·²å¯ç”¨çš„éªŒè¯ç ç±»å‹
// @Summary è·å–å·²å¯ç”¨çš„éªŒè¯ç ç±»å‹
// @Tags éªŒè¯ç 
// @Produce json
// @Success 200 {object} response.Response{data=[]string}
// @Router /captcha/types [get]
func (c *CaptchaController) GetEnabledTypes(ctx *gin.Context) {
    types := c.captchaManager.GetEnabledTypes()
    response.OkWithData(types, ctx)
}
```

---

## ğŸ” ç™»å½•æ—¶éªŒè¯

```go
// Login ç™»å½•
func (s *AuthService) Login(ctx context.Context, req *LoginRequest) (*TokenResponse, error) {
    // 1. æ ¹æ®ç™»å½•ç±»å‹éªŒè¯éªŒè¯ç 
    switch req.GrantType {
    case "password":
        // å¯†ç ç™»å½•ï¼šéªŒè¯å›¾å½¢éªŒè¯ç ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        if s.captchaManager.IsEnabled(CaptchaTypeImage) {
            if req.CaptchaID == "" || req.CaptchaCode == "" {
                return nil, errors.New("è¯·è¾“å…¥å›¾å½¢éªŒè¯ç ")
            }
            if err := s.captchaManager.Verify(ctx, CaptchaTypeImage, req.CaptchaID, req.CaptchaCode); err != nil {
                return nil, err
            }
        }
        
    case "sms":
        // çŸ­ä¿¡ç™»å½•ï¼šéªŒè¯çŸ­ä¿¡éªŒè¯ç 
        if !s.captchaManager.IsEnabled(CaptchaTypeSMS) {
            return nil, errors.New("çŸ­ä¿¡éªŒè¯ç åŠŸèƒ½æœªå¯ç”¨")
        }
        if err := s.captchaManager.Verify(ctx, CaptchaTypeSMS, req.CaptchaID, req.CaptchaCode); err != nil {
            return nil, err
        }
        
    case "email":
        // é‚®ç®±ç™»å½•ï¼šéªŒè¯é‚®ç®±éªŒè¯ç 
        if !s.captchaManager.IsEnabled(CaptchaTypeEmail) {
            return nil, errors.New("é‚®ç®±éªŒè¯ç åŠŸèƒ½æœªå¯ç”¨")
        }
        if err := s.captchaManager.Verify(ctx, CaptchaTypeEmail, req.CaptchaID, req.CaptchaCode); err != nil {
            return nil, err
        }
    }
    
    // 2. æ‰§è¡Œç™»å½•é€»è¾‘
    // ...
}
```

---

## ğŸ§ª å•å…ƒæµ‹è¯•ç¤ºä¾‹

```go
// MockCaptchaProvider Mock éªŒè¯ç æä¾›è€…
type MockCaptchaProvider struct {
    mock.Mock
}

func (m *MockCaptchaProvider) GetType() CaptchaType {
    args := m.Called()
    return args.Get(0).(CaptchaType)
}

func (m *MockCaptchaProvider) Generate(ctx context.Context, target string) (*CaptchaData, error) {
    args := m.Called(ctx, target)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*CaptchaData), args.Error(1)
}

func (m *MockCaptchaProvider) Verify(ctx context.Context, captchaID string, code string) error {
    args := m.Called(ctx, captchaID, code)
    return args.Error(0)
}

func (m *MockCaptchaProvider) IsEnabled() bool {
    args := m.Called()
    return args.Bool(0)
}

// æµ‹è¯•ç”¨ä¾‹
func TestCaptchaManager_Generate(t *testing.T) {
    mockProvider := new(MockCaptchaProvider)
    mockProvider.On("GetType").Return(CaptchaTypeImage)
    mockProvider.On("Generate", mock.Anything, "").Return(&CaptchaData{
        ID:   "test-id",
        Type: CaptchaTypeImage,
        Data: "base64-image-data",
    }, nil)
    
    manager := &CaptchaManager{
        providers: map[CaptchaType]CaptchaProvider{
            CaptchaTypeImage: mockProvider,
        },
    }
    
    data, err := manager.Generate(context.Background(), CaptchaTypeImage, "")
    assert.NoError(t, err)
    assert.Equal(t, "test-id", data.ID)
    assert.Equal(t, CaptchaTypeImage, data.Type)
    
    mockProvider.AssertExpectations(t)
}
```

---

## ğŸ“¦ ç›®å½•ç»“æ„

```
internal/
â”œâ”€â”€ infrastructure/
â”‚   â””â”€â”€ captcha/
â”‚       â”œâ”€â”€ captcha.go              # æ ¸å¿ƒæ¥å£å®šä¹‰
â”‚       â”œâ”€â”€ manager.go              # éªŒè¯ç ç®¡ç†å™¨
â”‚       â”œâ”€â”€ image_provider.go       # å›¾å½¢éªŒè¯ç å®ç°
â”‚       â”œâ”€â”€ sms_provider.go         # çŸ­ä¿¡éªŒè¯ç å®ç°
â”‚       â”œâ”€â”€ email_provider.go       # é‚®ç®±éªŒè¯ç å®ç°
â”‚       â”œâ”€â”€ sms/
â”‚       â”‚   â”œâ”€â”€ provider.go         # çŸ­ä¿¡æœåŠ¡æ¥å£
â”‚       â”‚   â”œâ”€â”€ aliyun.go          # é˜¿é‡Œäº‘çŸ­ä¿¡å®ç°
â”‚       â”‚   â””â”€â”€ tencent.go         # è…¾è®¯äº‘çŸ­ä¿¡å®ç°
â”‚       â”œâ”€â”€ email/
â”‚       â”‚   â”œâ”€â”€ provider.go         # é‚®ä»¶æœåŠ¡æ¥å£
â”‚       â”‚   â””â”€â”€ smtp.go            # SMTP é‚®ä»¶å®ç°
â”‚       â””â”€â”€ utils.go               # å·¥å…·å‡½æ•°
â”œâ”€â”€ controller/
â”‚   â””â”€â”€ captcha.go                 # éªŒè¯ç æ§åˆ¶å™¨
â””â”€â”€ service/
    â””â”€â”€ auth.go                    # è®¤è¯æœåŠ¡ï¼ˆä½¿ç”¨éªŒè¯ç ï¼‰
```

---

## âœ… ä¼˜åŠ¿

1. **æ¥å£æŠ½è±¡**ï¼šæ‰€æœ‰éªŒè¯ç ç±»å‹å®ç°ç»Ÿä¸€æ¥å£ï¼Œæ˜“äºæ‰©å±•
2. **ç­–ç•¥æ¨¡å¼**ï¼šé€šè¿‡é…ç½®åŠ¨æ€é€‰æ‹©å¯ç”¨çš„éªŒè¯ç ç±»å‹
3. **ä¾èµ–æ³¨å…¥**ï¼šä¾¿äºå•å…ƒæµ‹è¯•å’Œ Mock
4. **é…ç½®é©±åŠ¨**ï¼šæ— éœ€ä¿®æ”¹ä»£ç å³å¯è°ƒæ•´éªŒè¯ç ç­–ç•¥
5. **é¢‘ç‡é™åˆ¶**ï¼šé˜²æ­¢éªŒè¯ç è¢«æ¶æ„åˆ·å–
6. **ä¸€æ¬¡æ€§ä½¿ç”¨**ï¼šéªŒè¯åè‡ªåŠ¨åˆ é™¤ï¼Œæé«˜å®‰å…¨æ€§
7. **æ•°æ®è„±æ•**ï¼šè¿”å›è„±æ•çš„æ‰‹æœºå·å’Œé‚®ç®±

---

## ğŸ”„ æ‰©å±•æ–°ç±»å‹

æ·»åŠ æ–°çš„éªŒè¯ç ç±»å‹ï¼ˆå¦‚æ»‘å—éªŒè¯ç ï¼‰åªéœ€ï¼š

1. å®ç° `CaptchaProvider` æ¥å£
2. åœ¨é…ç½®æ–‡ä»¶ä¸­æ·»åŠ é…ç½®é¡¹
3. åœ¨ `CaptchaManager` ä¸­æ³¨å†Œæ–°æä¾›è€…

```go
// SliderCaptchaProvider æ»‘å—éªŒè¯ç æä¾›è€…
type SliderCaptchaProvider struct {
    config *CaptchaConfig
    redis  *redis.Client
}

func (p *SliderCaptchaProvider) GetType() CaptchaType {
    return CaptchaType("slider")
}

// å®ç°å…¶ä»–æ¥å£æ–¹æ³•...
```

---

## ğŸ“ æ€»ç»“

è¿™ä¸ªè®¾è®¡æ–¹æ¡ˆæä¾›äº†ï¼š

- âœ… çµæ´»çš„æ¥å£è®¾è®¡
- âœ… å¯é…ç½®çš„éªŒè¯ç ç­–ç•¥
- âœ… æ˜“äºæ‰©å±•çš„æ¶æ„
- âœ… å®Œæ•´çš„å®ç°ç¤ºä¾‹
- âœ… å•å…ƒæµ‹è¯•æ”¯æŒ

é€šè¿‡è¿™ä¸ªè®¾è®¡ï¼Œå¯ä»¥è½»æ¾æ”¯æŒå¤šç§éªŒè¯ç ç±»å‹ï¼Œå¹¶é€šè¿‡é…ç½®çµæ´»æ§åˆ¶å¯ç”¨/ç¦ç”¨ï¼Œæ»¡è¶³ä¸åŒåœºæ™¯çš„éœ€æ±‚ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v1.0  
**æœ€åæ›´æ–°ï¼š** 2026-01-12  
**ç»´æŠ¤è€…ï¼š** é¡¹ç›®å›¢é˜Ÿ
