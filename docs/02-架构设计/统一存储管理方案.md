# 统一存储管理方案

## 1. 方案概述

本方案设计了一个灵活的统一存储管理系统，支持多种存储类型（S3、本地存储等）和多存储环境配置，并提供完整的附件管理功能。

### 核心特性

- ✅ **多存储类型支持**：S3（MinIO/AWS S3）、本地存储、阿里云 OSS 等
- ✅ **多环境配置**：支持配置多个存储环境（多个桶、多个目录）
- ✅ **统一接口抽象**：Storage 接口统一所有存储操作
- ✅ **动态配置管理**：存储配置存储在数据库，支持动态增删改
- ✅ **附件业务绑定**：附件与业务数据关联，支持多对多关系
- ✅ **附件生命周期管理**：上传、下载、删除、过期清理

## 2. 架构设计

### 2.1 分层架构

```
┌─────────────────────────────────────────────────────────┐
│                    Controller 层                         │
│              (AttachmentController)                      │
└─────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────┐
│                    Service 层                            │
│         (AttachmentService, StorageService)              │
└─────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────┐
│                 StorageManager (统一管理器)              │
│          - 管理多个存储环境                               │
│          - 根据环境 ID 获取对应的 Storage 实例            │
└─────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────┐
│              Storage 接口 (统一抽象)                      │
│   - Upload()   - Download()   - Delete()                │
│   - GetURL()   - Exists()     - List()                  │
└─────────────────────────────────────────────────────────┘
                            ↓
        ┌───────────────────┼───────────────────┐
        ↓                   ↓                   ↓
┌──────────────┐   ┌──────────────┐   ┌──────────────┐
│ S3Storage    │   │ LocalStorage │   │ OSSStorage   │
│ (MinIO/AWS)  │   │ (本地磁盘)    │   │ (阿里云)      │
└──────────────┘   └──────────────┘   └──────────────┘
```

### 2.2 核心组件

#### Storage 接口（统一抽象）
```go
type Storage interface {
    // 上传文件
    Upload(ctx context.Context, key string, reader io.Reader, size int64) error
    
    // 下载文件
    Download(ctx context.Context, key string) (io.ReadCloser, error)
    
    // 删除文件
    Delete(ctx context.Context, key string) error
    
    // 获取访问 URL
    GetURL(ctx context.Context, key string, expires time.Duration) (string, error)
    
    // 检查文件是否存在
    Exists(ctx context.Context, key string) (bool, error)
    
    // 列出文件
    List(ctx context.Context, prefix string) ([]string, error)
    
    // 获取文件信息
    GetInfo(ctx context.Context, key string) (*FileInfo, error)
}
```

#### StorageManager（存储管理器）
```go
type StorageManager interface {
    // 根据环境 ID 获取 Storage 实例
    GetStorage(envId int64) (Storage, error)
    
    // 根据环境编码获取 Storage 实例
    GetStorageByCode(envCode string) (Storage, error)
    
    // 获取默认 Storage（当未指定环境时使用）
    GetDefaultStorage() (Storage, error)
    
    // 重新加载配置（从数据库）
    ReloadConfig() error
    
    // 注册新的存储类型
    RegisterStorageType(typeName string, factory StorageFactory) error
}
```

## 3. 数据库设计

### 3.1 存储环境配置表（s_storage_env）

```sql
CREATE TABLE IF NOT EXISTS s_storage_env (
    env_id BIGSERIAL PRIMARY KEY,
    env_name VARCHAR(100) NOT NULL,              -- 环境名称（如：用户头像、商品图片）
    env_code VARCHAR(50) UNIQUE NOT NULL,        -- 环境编码（唯一标识）
    storage_type VARCHAR(20) NOT NULL,           -- 存储类型：s3/local/oss
    is_default BOOLEAN DEFAULT FALSE,            -- 是否默认环境（有且仅有一个为 true）
    status CHAR(1) DEFAULT '0',                  -- 状态：0正常 1停用
    
    -- S3 配置（JSON 格式）
    config JSONB NOT NULL,                       -- 存储配置（根据类型不同而不同）
    /*
    S3 配置示例：
    {
        "endpoint": "http://localhost:9000",
        "accessKey": "minioadmin",
        "secretKey": "minioadmin",
        "bucket": "user-avatars",
        "region": "us-east-1",
        "useSSL": false
    }
    
    本地存储配置示例：
    {
        "basePath": "/data/storage/uploads",
        "urlPrefix": "http://localhost:8080/files"
    }
    
    阿里云 OSS 配置示例：
    {
        "endpoint": "oss-cn-hangzhou.aliyuncs.com",
        "accessKeyId": "xxx",
        "accessKeySecret": "xxx",
        "bucket": "my-bucket"
    }
    */
    
    -- 访问控制
    max_file_size BIGINT DEFAULT 10485760,       -- 最大文件大小（字节），默认 10MB
    allowed_extensions TEXT,                     -- 允许的文件扩展名（逗号分隔）
    
    remark VARCHAR(500),
    create_by BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_by BIGINT,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);

CREATE INDEX idx_storage_env_code ON s_storage_env(env_code);
CREATE INDEX idx_storage_env_type ON s_storage_env(storage_type);
CREATE INDEX idx_storage_env_default ON s_storage_env(is_default);

COMMENT ON TABLE s_storage_env IS '存储环境配置表';
COMMENT ON COLUMN s_storage_env.env_code IS '环境编码，用于代码中引用，如：user_avatar, product_image';
COMMENT ON COLUMN s_storage_env.storage_type IS '存储类型：s3(MinIO/AWS S3), local(本地存储), oss(阿里云OSS)';
COMMENT ON COLUMN s_storage_env.config IS '存储配置，JSON 格式，根据 storage_type 不同而不同';
COMMENT ON COLUMN s_storage_env.is_default IS '是否默认环境，系统保证有且仅有一个为 true';
```

### 3.3 默认环境约束

**重要规则：系统必须保证有且仅有一个默认环境**

#### 约束说明
1. **有且仅有一个**：任何时候都必须有一个默认环境，且只能有一个
2. **自动切换**：当设置新的默认环境时，自动取消原默认环境
3. **删除保护**：不允许删除默认环境，必须先设置其他环境为默认
4. **初始化**：系统初始化时必须创建一个默认环境

#### 实现逻辑

```go
// StorageEnvService 接口
type StorageEnvService interface {
    // 创建存储环境
    Create(ctx context.Context, env *StorageEnv) error
    
    // 更新存储环境
    Update(ctx context.Context, env *StorageEnv) error
    
    // 删除存储环境
    Delete(ctx context.Context, envId int64) error
    
    // 设置默认环境
    SetDefault(ctx context.Context, envId int64) error
    
    // 获取默认环境
    GetDefault(ctx context.Context) (*StorageEnv, error)
}

// 创建存储环境
func (s *storageEnvService) Create(ctx context.Context, env *StorageEnv) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 1. 检查是否已有默认环境
        var count int64
        if err := tx.Model(&StorageEnv{}).Where("is_default = ?", true).Count(&count).Error; err != nil {
            return err
        }
        
        // 2. 如果没有默认环境，强制设置为默认
        if count == 0 {
            env.IsDefault = true
        }
        
        // 3. 如果要设置为默认，先取消其他默认环境
        if env.IsDefault {
            if err := tx.Model(&StorageEnv{}).
                Where("is_default = ?", true).
                Update("is_default", false).Error; err != nil {
                return err
            }
        }
        
        // 4. 创建环境
        return tx.Create(env).Error
    })
}

// 设置默认环境
func (s *storageEnvService) SetDefault(ctx context.Context, envId int64) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 1. 检查环境是否存在
        var env StorageEnv
        if err := tx.Where("env_id = ?", envId).First(&env).Error; err != nil {
            return fmt.Errorf("环境不存在")
        }
        
        // 2. 取消所有默认环境
        if err := tx.Model(&StorageEnv{}).
            Where("is_default = ?", true).
            Update("is_default", false).Error; err != nil {
            return err
        }
        
        // 3. 设置新的默认环境
        return tx.Model(&StorageEnv{}).
            Where("env_id = ?", envId).
            Update("is_default", true).Error
    })
}

// 删除存储环境
func (s *storageEnvService) Delete(ctx context.Context, envId int64) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 1. 检查是否为默认环境
        var env StorageEnv
        if err := tx.Where("env_id = ?", envId).First(&env).Error; err != nil {
            return fmt.Errorf("环境不存在")
        }
        
        if env.IsDefault {
            return fmt.Errorf("不能删除默认环境，请先设置其他环境为默认")
        }
        
        // 2. 检查是否有附件使用该环境
        var attachmentCount int64
        if err := tx.Model(&Attachment{}).
            Where("env_id = ?", envId).
            Count(&attachmentCount).Error; err != nil {
            return err
        }
        
        if attachmentCount > 0 {
            return fmt.Errorf("该环境下还有 %d 个附件，无法删除", attachmentCount)
        }
        
        // 3. 删除环境
        return tx.Delete(&StorageEnv{}, envId).Error
    })
}

// 获取默认环境
func (s *storageEnvService) GetDefault(ctx context.Context) (*StorageEnv, error) {
    var env StorageEnv
    if err := s.db.Where("is_default = ? AND status = ?", true, "0").First(&env).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, fmt.Errorf("未配置默认存储环境")
        }
        return nil, err
    }
    return &env, nil
}
```

### 3.2 附件表（biz_attachment）

```sql
CREATE TABLE IF NOT EXISTS biz_attachment (
    attachment_id BIGSERIAL PRIMARY KEY,
    env_id BIGINT NOT NULL,                      -- 存储环境 ID
    
    -- 文件信息
    file_name VARCHAR(255) NOT NULL,             -- 原始文件名
    file_key VARCHAR(500) NOT NULL,              -- 存储路径/Key
    file_size BIGINT NOT NULL,                   -- 文件大小（字节）
    file_type VARCHAR(100),                      -- 文件类型（MIME Type）
    file_ext VARCHAR(20),                        -- 文件扩展名
    
    -- 业务关联
    business_type VARCHAR(50),                   -- 业务类型（如：user, product, order）
    business_id VARCHAR(100),                    -- 业务 ID
    business_field VARCHAR(50),                  -- 业务字段（如：avatar, cover, attachment）
    
    -- 访问控制
    is_public BOOLEAN DEFAULT FALSE,             -- 是否公开访问
    access_url VARCHAR(1000),                    -- 访问 URL（公开文件）
    
    -- 元数据
    metadata JSONB,                              -- 额外元数据（如：图片宽高、视频时长等）
    
    -- 状态管理
    status CHAR(1) DEFAULT '0',                  -- 状态：0正常 1已删除
    expire_time TIMESTAMP,                       -- 过期时间（临时文件）
    
    create_by BIGINT,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_attachment_env ON biz_attachment(env_id);
CREATE INDEX idx_attachment_business ON biz_attachment(business_type, business_id);
CREATE INDEX idx_attachment_key ON biz_attachment(file_key);
CREATE INDEX idx_attachment_expire ON biz_attachment(expire_time);

COMMENT ON TABLE biz_attachment IS '附件表';
COMMENT ON COLUMN biz_attachment.business_type IS '业务类型，用于区分不同业务模块';
COMMENT ON COLUMN biz_attachment.business_id IS '业务 ID，关联具体的业务数据';
COMMENT ON COLUMN biz_attachment.business_field IS '业务字段，同一业务可能有多个附件字段';
COMMENT ON COLUMN biz_attachment.metadata IS '元数据，JSON 格式，如：{"width":800,"height":600}';
```

## 4. 接口设计

### 4.1 Storage 接口实现

#### S3Storage
```go
type S3Storage struct {
    client    *minio.Client
    bucket    string
    region    string
    urlPrefix string
}

func NewS3Storage(config S3Config) (*S3Storage, error) {
    // 初始化 MinIO/S3 客户端
}
```

#### LocalStorage
```go
type LocalStorage struct {
    basePath  string  // 本地存储根目录
    urlPrefix string  // URL 前缀
}

func NewLocalStorage(config LocalConfig) (*LocalStorage, error) {
    // 初始化本地存储
}
```

### 4.2 StorageManager 实现

```go
type storageManager struct {
    db            *gorm.DB
    storages      map[int64]Storage      // envId -> Storage 实例
    defaultEnvId  int64
    factories     map[string]StorageFactory
    mu            sync.RWMutex
}

func (m *storageManager) GetStorage(envId int64) (Storage, error) {
    m.mu.RLock()
    storage, exists := m.storages[envId]
    m.mu.RUnlock()
    
    if exists {
        return storage, nil
    }
    
    // 从数据库加载配置并创建 Storage 实例
    return m.loadStorage(envId)
}
```

### 4.3 AttachmentService

```go
type AttachmentService interface {
    // 上传附件
    Upload(ctx context.Context, req *UploadRequest) (*Attachment, error)
    
    // 下载附件
    Download(ctx context.Context, attachmentId int64) (io.ReadCloser, string, error)
    
    // 删除附件
    Delete(ctx context.Context, attachmentId int64) error
    
    // 获取附件 URL
    GetURL(ctx context.Context, attachmentId int64, expires time.Duration) (string, error)
    
    // 根据业务查询附件列表
    ListByBusiness(ctx context.Context, businessType, businessId string) ([]*Attachment, error)
    
    // 绑定附件到业务
    BindToBusiness(ctx context.Context, attachmentId int64, businessType, businessId, businessField string) error
    
    // 清理过期附件
    CleanExpired(ctx context.Context) error
}
```

## 5. 使用示例

### 5.1 配置存储环境

```go
// 配置 MinIO 环境 - 用户头像
env1 := &StorageEnv{
    EnvName:     "用户头像存储",
    EnvCode:     "user_avatar",
    StorageType: "s3",
    IsDefault:   true,
    Config: map[string]interface{}{
        "endpoint":  "http://localhost:9000",
        "accessKey": "minioadmin",
        "secretKey": "minioadmin",
        "bucket":    "user-avatars",
        "region":    "us-east-1",
    },
    MaxFileSize:       5 * 1024 * 1024, // 5MB
    AllowedExtensions: "jpg,jpeg,png,gif",
}

// 配置本地存储 - 商品图片
env2 := &StorageEnv{
    EnvName:     "商品图片存储",
    EnvCode:     "product_image",
    StorageType: "local",
    Config: map[string]interface{}{
        "basePath":  "/data/storage/products",
        "urlPrefix": "http://localhost:8080/files/products",
    },
    MaxFileSize:       10 * 1024 * 1024, // 10MB
    AllowedExtensions: "jpg,jpeg,png,webp",
}
```

### 5.2 上传附件

```go
// Controller 层
func (c *AttachmentController) Upload(ctx *gin.Context) {
    file, _ := ctx.FormFile("file")
    envCode := ctx.PostForm("envCode")      // 存储环境编码（可选，不传则使用默认环境）
    businessType := ctx.PostForm("businessType")
    businessId := ctx.PostForm("businessId")
    
    req := &UploadRequest{
        File:         file,
        EnvCode:      envCode,              // 如果为空，Service 层会使用默认环境
        BusinessType: businessType,
        BusinessId:   businessId,
    }
    
    attachment, err := c.attachmentService.Upload(ctx.Request.Context(), req)
    if err != nil {
        response.Error(ctx, err.Error())
        return
    }
    
    response.Success(ctx, attachment)
}

// Service 层
func (s *attachmentService) Upload(ctx context.Context, req *UploadRequest) (*Attachment, error) {
    // 1. 根据 envCode 获取存储环境（如果未指定，使用默认环境）
    var env *StorageEnv
    var err error
    
    if req.EnvCode != "" {
        env, err = s.getEnvByCode(req.EnvCode)
    } else {
        // 使用默认环境
        env, err = s.storageEnvService.GetDefault(ctx)
    }
    
    if err != nil {
        return nil, fmt.Errorf("获取存储环境失败: %w", err)
    }
    
    // 2. 验证文件大小和类型
    if err := s.validateFile(req.File, env); err != nil {
        return nil, err
    }
    
    // 3. 获取 Storage 实例
    storage, err := s.storageManager.GetStorage(env.EnvId)
    if err != nil {
        return nil, err
    }
    
    // 4. 生成文件 Key
    fileKey := s.generateFileKey(req.File.Filename)
    
    // 5. 上传文件
    file, _ := req.File.Open()
    defer file.Close()
    
    if err := storage.Upload(ctx, fileKey, file, req.File.Size); err != nil {
        return nil, err
    }
    
    // 6. 保存附件记录
    attachment := &Attachment{
        EnvId:        env.EnvId,
        FileName:     req.File.Filename,
        FileKey:      fileKey,
        FileSize:     req.File.Size,
        BusinessType: req.BusinessType,
        BusinessId:   req.BusinessId,
    }
    
    if err := s.db.Create(attachment).Error; err != nil {
        // 回滚：删除已上传的文件
        storage.Delete(ctx, fileKey)
        return nil, err
    }
    
    return attachment, nil
}
```

### 5.3 获取附件 URL

```go
// 获取临时访问 URL（私有文件）
url, err := attachmentService.GetURL(ctx, attachmentId, 1*time.Hour)

// 获取永久 URL（公开文件）
url, err := attachmentService.GetURL(ctx, attachmentId, 0)
```

### 5.4 查询业务附件

```go
// 查询用户的所有头像
attachments, err := attachmentService.ListByBusiness(ctx, "user", "123")

// 查询订单的所有附件
attachments, err := attachmentService.ListByBusiness(ctx, "order", "456")
```

## 6. 容器集成

### 6.1 容器初始化

```go
// internal/container/container.go

type Container interface {
    // ... 其他方法
    
    // 获取存储管理器（高层抽象）
    GetStorageManager() storage.StorageManager
    
    // 获取附件服务
    GetAttachmentService() service.AttachmentService
}

func (c *container) GetStorageManager() storage.StorageManager {
    if c.storageManager == nil {
        c.storageManager = storage.NewStorageManager(c.db, c.logger)
        
        // 注册存储类型
        c.storageManager.RegisterStorageType("s3", storage.NewS3StorageFactory())
        c.storageManager.RegisterStorageType("local", storage.NewLocalStorageFactory())
        c.storageManager.RegisterStorageType("oss", storage.NewOSSStorageFactory())
    }
    return c.storageManager
}

func (c *container) GetAttachmentService() service.AttachmentService {
    if c.attachmentService == nil {
        c.attachmentService = service.NewAttachmentService(
            c.db,
            c.GetStorageManager(),
            c.logger,
        )
    }
    return c.attachmentService
}
```

### 6.2 不再直接暴露 S3

```go
// ❌ 旧方式：直接暴露 S3
func (c *container) GetS3Client() *minio.Client {
    // ...
}

// ✅ 新方式：通过 StorageManager 统一管理
func (c *container) GetStorageManager() storage.StorageManager {
    // ...
}
```

## 7. 优势总结

### 7.1 灵活性
- ✅ 支持多种存储类型（S3、本地、OSS 等）
- ✅ 支持多个存储环境（多个桶、多个目录）
- ✅ 配置存储在数据库，支持动态修改
- ✅ 自动使用默认环境，避免未指定环境时报错

### 7.2 可扩展性
- ✅ 统一的 Storage 接口，易于添加新的存储类型
- ✅ 工厂模式注册存储类型，解耦具体实现
- ✅ 附件与业务解耦，支持任意业务类型

### 7.3 易用性
- ✅ 通过环境编码（envCode）简化使用
- ✅ 未指定环境时自动使用默认环境
- ✅ 自动管理文件生命周期
- ✅ 统一的错误处理和日志记录

### 7.4 安全性
- ✅ 文件大小和类型验证
- ✅ 支持公开和私有访问控制
- ✅ 临时 URL 支持（带过期时间）
- ✅ 默认环境保护机制（不能删除默认环境）

### 7.5 可靠性
- ✅ 有且仅有一个默认环境的约束保证
- ✅ 事务保证数据一致性
- ✅ 删除前检查依赖关系
- ✅ 自动切换默认环境机制

## 8. 实施步骤

1. ✅ 创建数据库表（s_storage_env、biz_attachment）
2. ✅ 实现 Storage 接口和各种实现（S3Storage、LocalStorage）
3. ✅ 实现 StorageManager
4. ✅ 实现 AttachmentService
5. ✅ 实现 AttachmentController
6. ✅ 更新容器，移除直接的 S3 暴露
7. ✅ 编写单元测试
8. ✅ 编写使用文档

---

**最后更新：** 2024-12-20  
**版本：** v1.0.0
