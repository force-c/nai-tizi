# 充血模型设计指南

## 设计原则

### 职责划分

```
Controller 层：
- 参数绑定和格式验证
- HTTP 响应处理
- 调用 Service

Service 层：
- 复杂业务编排
- 多模型协调
- 事务管理
- 外部服务调用（如 Casbin）
- 跨领域逻辑

Model 层（充血）：
- 基础 CRUD 操作
- 单表查询逻辑
- 业务规则验证
- 领域行为
- 状态转换
```

## 实践示例

### 1. Model 层 - 充血实现

```go
package model

import (
    "errors"
    "time"
    "gorm.io/gorm"
)

// Role 角色领域模型
type Role struct {
    RoleId    int64          `gorm:"column:role_id;primaryKey" json:"roleId"`
    RoleKey   string         `gorm:"column:role_key;uniqueIndex" json:"roleKey"`
    RoleName  string         `gorm:"column:role_name" json:"roleName"`
    Status    string         `gorm:"column:status;default:'0'" json:"status"`
    IsSystem  bool           `gorm:"column:is_system" json:"isSystem"`
    SortOrder int            `gorm:"column:sort_order" json:"sortOrder"`
    Remark    string         `gorm:"column:remark" json:"remark"`
    CreateBy  int64          `gorm:"column:create_by" json:"createBy"`
    CreatedAt time.Time      `gorm:"column:created_at" json:"createdAt"`
    UpdatedAt time.Time      `gorm:"column:updated_at" json:"updatedAt"`
    DeletedAt gorm.DeletedAt `gorm:"column:deleted_at;index" json:"-"`
}

func (*Role) TableName() string { return "s_role" }

// ============ 业务规则验证 ============

// Validate 验证角色数据
func (r *Role) Validate() error {
    if r.RoleKey == "" {
        return errors.New("角色标识不能为空")
    }
    if r.RoleName == "" {
        return errors.New("角色名称不能为空")
    }
    if len(r.RoleKey) > 50 {
        return errors.New("角色标识长度不能超过50")
    }
    return nil
}

// CanDelete 判断角色是否可以删除
func (r *Role) CanDelete() error {
    if r.IsSystem {
        return errors.New("系统内置角色不能删除")
    }
    return nil
}

// CanDisable 判断角色是否可以停用
func (r *Role) CanDisable() error {
    if r.IsSystem {
        return errors.New("系统内置角色不能停用")
    }
    return nil
}

// ============ 状态转换 ============

// Enable 启用角色
func (r *Role) Enable() error {
    if r.Status == "0" {
        return errors.New("角色已经是启用状态")
    }
    r.Status = "0"
    return nil
}

// Disable 停用角色
func (r *Role) Disable() error {
    if err := r.CanDisable(); err != nil {
        return err
    }
    if r.Status == "1" {
        return errors.New("角色已经是停用状态")
    }
    r.Status = "1"
    return nil
}

// IsActive 判断角色是否激活
func (r *Role) IsActive() bool {
    return r.Status == "0"
}

// ============ 基础查询（单表） ============

// FindByID 根据ID查询角色
func (*Role) FindByID(db *gorm.DB, roleId int64) (*Role, error) {
    var role Role
    err := db.Where("role_id = ?", roleId).First(&role).Error
    if err != nil {
        return nil, err
    }
    return &role, nil
}

// FindByRoleKey 根据角色标识查询
func (*Role) FindByRoleKey(db *gorm.DB, roleKey string) (*Role, error) {
    var role Role
    err := db.Where("role_key = ?", roleKey).First(&role).Error
    if err != nil {
        return nil, err
    }
    return &role, nil
}

// ExistsByRoleKey 检查角色标识是否存在
func (*Role) ExistsByRoleKey(db *gorm.DB, roleKey string) (bool, error) {
    var count int64
    err := db.Model(&Role{}).Where("role_key = ?", roleKey).Count(&count).Error
    return count > 0, err
}

// FindAll 查询所有角色
func (*Role) FindAll(db *gorm.DB) ([]Role, error) {
    var roles []Role
    err := db.Order("sort_order ASC, created_at DESC").Find(&roles).Error
    return roles, err
}

// FindByStatus 根据状态查询角色
func (*Role) FindByStatus(db *gorm.DB, status string) ([]Role, error) {
    var roles []Role
    err := db.Where("status = ?", status).
        Order("sort_order ASC, created_at DESC").
        Find(&roles).Error
    return roles, err
}

// ============ 基础 CRUD ============

// Create 创建角色
func (r *Role) Create(db *gorm.DB) error {
    if err := r.Validate(); err != nil {
        return err
    }
    return db.Create(r).Error
}

// Update 更新角色
func (r *Role) Update(db *gorm.DB) error {
    if err := r.Validate(); err != nil {
        return err
    }
    return db.Save(r).Error
}

// Delete 删除角色
func (r *Role) Delete(db *gorm.DB) error {
    if err := r.CanDelete(); err != nil {
        return err
    }
    return db.Delete(r).Error
}

// ============ 分页查询（带条件） ============

// RoleQuery 角色查询条件
type RoleQuery struct {
    RoleName string
    Status   string
    PageNum  int
    PageSize int
}

// FindByQuery 根据条件分页查询
func (*Role) FindByQuery(db *gorm.DB, query RoleQuery) ([]Role, int64, error) {
    var roles []Role
    var total int64

    q := db.Model(&Role{})

    // 条件过滤
    if query.RoleName != "" {
        q = q.Where("role_name LIKE ?", "%"+query.RoleName+"%")
    }
    if query.Status != "" {
        q = q.Where("status = ?", query.Status)
    }

    // 统计总数
    if err := q.Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // 分页查询
    offset := (query.PageNum - 1) * query.PageSize
    if err := q.Offset(offset).Limit(query.PageSize).
        Order("sort_order ASC, created_at DESC").
        Find(&roles).Error; err != nil {
        return nil, 0, err
    }

    return roles, total, nil
}
```

### 2. Service 层 - 业务编排

```go
package service

import (
    "context"
    "fmt"
    "github.com/force-c/nai-tizi/internal/domain/model"
    "github.com/force-c/nai-tizi/internal/logger"
    "go.uber.org/zap"
    "gorm.io/gorm"
)

type roleService struct {
    db            *gorm.DB
    casbinService CasbinService
    logger        logger.Logger
}

// Create 创建角色（Service 负责业务编排）
func (s *roleService) Create(ctx context.Context, role *model.Role) error {
    // 1. 检查角色标识是否已存在（使用 Model 方法）
    exists, err := new(model.Role).ExistsByRoleKey(s.db, role.RoleKey)
    if err != nil {
        s.logger.Error("检查角色标识失败", zap.Error(err))
        return fmt.Errorf("检查角色标识失败: %w", err)
    }
    if exists {
        return fmt.Errorf("角色标识已存在: %s", role.RoleKey)
    }

    // 2. 创建角色（Model 内部会验证）
    if err := role.Create(s.db); err != nil {
        s.logger.Error("创建角色失败", zap.Error(err))
        return fmt.Errorf("创建角色失败: %w", err)
    }

    // 3. 记录日志
    s.logger.Info("创建角色成功",
        zap.Int64("roleId", role.RoleId),
        zap.String("roleKey", role.RoleKey))

    return nil
}

// Update 更新角色
func (s *roleService) Update(ctx context.Context, role *model.Role) error {
    // 1. 查询原角色
    oldRole, err := new(model.Role).FindByID(s.db, role.RoleId)
    if err != nil {
        return fmt.Errorf("角色不存在: %w", err)
    }

    // 2. 检查系统角色
    if oldRole.IsSystem && role.RoleKey != oldRole.RoleKey {
        return fmt.Errorf("系统角色不能修改角色标识")
    }

    // 3. 更新角色（Model 内部会验证）
    if err := role.Update(s.db); err != nil {
        s.logger.Error("更新角色失败", zap.Error(err))
        return fmt.Errorf("更新角色失败: %w", err)
    }

    s.logger.Info("更新角色成功", zap.Int64("roleId", role.RoleId))
    return nil
}

// Delete 删除角色（复杂业务逻辑）
func (s *roleService) Delete(ctx context.Context, roleId int64) error {
    // 使用事务确保数据一致性
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 1. 查询角色
        role, err := new(model.Role).FindByID(tx, roleId)
        if err != nil {
            return fmt.Errorf("角色不存在: %w", err)
        }

        // 2. 检查是否可以删除（使用 Model 方法）
        if err := role.CanDelete(); err != nil {
            return err
        }

        // 3. 检查是否有用户使用该角色
        var userCount int64
        if err := tx.Model(&model.SUserRole{}).
            Where("role_id = ?", roleId).
            Count(&userCount).Error; err != nil {
            return fmt.Errorf("检查用户角色关联失败: %w", err)
        }
        if userCount > 0 {
            return fmt.Errorf("该角色已分配给 %d 个用户，不能删除", userCount)
        }

        // 4. 删除角色（Model 方法）
        if err := role.Delete(tx); err != nil {
            return fmt.Errorf("删除角色失败: %w", err)
        }

        // 5. 删除 Casbin 中的角色权限（外部服务）
        if err := s.casbinService.DeleteRole(ctx, role.RoleKey); err != nil {
            s.logger.Warn("删除 Casbin 角色失败", zap.Error(err))
            // 不影响主流程
        }

        s.logger.Info("删除角色成功", zap.Int64("roleId", roleId))
        return nil
    })
}

// List 分页查询角色列表
func (s *roleService) List(ctx context.Context, pageNum, pageSize int, roleName, status string) ([]model.Role, int64, error) {
    // 使用 Model 的查询方法
    query := model.RoleQuery{
        RoleName: roleName,
        Status:   status,
        PageNum:  pageNum,
        PageSize: pageSize,
    }

    roles, total, err := new(model.Role).FindByQuery(s.db, query)
    if err != nil {
        s.logger.Error("查询角色列表失败", zap.Error(err))
        return nil, 0, fmt.Errorf("查询角色列表失败: %w", err)
    }

    return roles, total, nil
}

// AssignRoleToUser 为用户分配角色（复杂业务编排）
func (s *roleService) AssignRoleToUser(ctx context.Context, userId, roleId, orgId int64) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 1. 检查用户是否存在
        var user model.User
        if err := tx.Where("user_id = ?", userId).First(&user).Error; err != nil {
            return fmt.Errorf("用户不存在")
        }

        // 2. 检查角色是否存在且激活
        role, err := new(model.Role).FindByID(tx, roleId)
        if err != nil {
            return fmt.Errorf("角色不存在")
        }
        if !role.IsActive() {
            return fmt.Errorf("角色已停用，不能分配")
        }

        // 3. 检查是否已分配
        var count int64
        if err := tx.Model(&model.SUserRole{}).
            Where("user_id = ? AND role_id = ?", userId, roleId).
            Count(&count).Error; err != nil {
            return fmt.Errorf("检查用户角色关联失败: %w", err)
        }
        if count > 0 {
            return fmt.Errorf("用户已拥有该角色")
        }

        // 4. 创建用户角色关联
        userRole := &model.SUserRole{
            UserId: userId,
            RoleId: roleId,
        }
        if err := tx.Create(userRole).Error; err != nil {
            return fmt.Errorf("分配角色失败: %w", err)
        }

        // 5. 同步到 Casbin（外部服务调用）
        if err := s.casbinService.AddRoleForUser(ctx, userId, orgId, role.RoleKey); err != nil {
            return fmt.Errorf("同步 Casbin 失败: %w", err)
        }

        s.logger.Info("分配角色成功",
            zap.Int64("userId", userId),
            zap.Int64("roleId", roleId))

        return nil
    })
}
```

### 3. Controller 层 - 简洁清晰

```go
package controller

import (
    "github.com/force-c/nai-tizi/internal/domain/request"
    "github.com/force-c/nai-tizi/internal/domain/response"
    "github.com/force-c/nai-tizi/internal/service"
    "github.com/gin-gonic/gin"
)

type RoleController struct {
    roleService service.RoleService
    logger      logger.Logger
}

// CreateRole 创建角色
func (c *RoleController) CreateRole(ctx *gin.Context) {
    // 1. 参数绑定
    var req request.CreateRoleRequest
    if err := ctx.ShouldBindJSON(&req); err != nil {
        response.BadRequest(ctx, "参数错误: "+err.Error())
        return
    }

    // 2. 转换为 Model
    role := &model.Role{
        RoleKey:   req.RoleKey,
        RoleName:  req.RoleName,
        SortOrder: req.SortOrder,
        Status:    req.Status,
        Remark:    req.Remark,
    }

    // 3. 调用 Service
    if err := c.roleService.Create(ctx.Request.Context(), role); err != nil {
        c.logger.Error("创建角色失败", zap.Error(err))
        response.InternalServerError(ctx, err.Error())
        return
    }

    // 4. 返回响应
    response.SuccessWithMsg(ctx, "创建角色成功", role)
}
```

## 总结

### 充血模型的优势

1. **单一职责** - 每层职责清晰
2. **可测试性** - Model 层可以独立测试
3. **可维护性** - 业务规则集中在 Model
4. **可复用性** - Model 方法可以在多个 Service 中复用
5. **领域驱动** - 符合 DDD 思想

### 实施建议

#### 立即可做：
1. ✅ 在 Model 中添加 `Validate()` 方法
2. ✅ 在 Model 中添加业务规则判断方法（如 `CanDelete()`）
3. ✅ 将简单查询逻辑移到 Model

#### 逐步优化：
1. 重构现有 Service，使用 Model 方法
2. 为复杂查询创建 Query 对象
3. 添加领域事件（如需要）

### 注意事项

1. **不要过度设计** - 简单的 CRUD 不需要太复杂
2. **保持平衡** - Model 不应该依赖外部服务
3. **事务管理** - 复杂事务仍然在 Service 层
4. **性能考虑** - 避免 N+1 查询问题
