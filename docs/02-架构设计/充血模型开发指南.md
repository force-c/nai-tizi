# 充血模型开发指南

## 快速参考

### Model 层方法模板

```go
// 1. 查询方法
func (m *Model) FindByID(db *gorm.DB, id int64) (*Model, error) {
    var model Model
    err := db.Where("id = ?", id).First(&model).Error
    if err != nil {
        return nil, err
    }
    return &model, nil
}

// 2. 批量冲突检查（性能优化关键）
func (m *Model) FindConflicts(db *gorm.DB, field1, field2 string) ([]Model, error) {
    var models []Model
    query := db.Model(&Model{})
    
    conditions := []string{}
    args := []interface{}{}
    
    if field1 != "" {
        conditions = append(conditions, "field1 = ?")
        args = append(args, field1)
    }
    if field2 != "" {
        conditions = append(conditions, "field2 = ?")
        args = append(args, field2)
    }
    
    if len(conditions) == 0 {
        return nil, nil
    }
    
    whereClause := strings.Join(conditions, " OR ")
    err := query.Where(whereClause, args...).Find(&models).Error
    return models, err
}

// 3. 统计方法
func (m *Model) CountChildren(db *gorm.DB, parentId int64) (int64, error) {
    var count int64
    err := db.Model(&Model{}).Where("parent_id = ?", parentId).Count(&count).Error
    return count, err
}

// 4. CRUD 方法
func (m *Model) Create(db *gorm.DB, model *Model) error {
    return db.Create(model).Error
}

func (m *Model) Update(db *gorm.DB, id int64, updates map[string]interface{}) error {
    return db.Model(&Model{}).Where("id = ?", id).Updates(updates).Error
}

func (m *Model) Delete(db *gorm.DB, id int64) error {
    return db.Where("id = ?", id).Delete(&Model{}).Error
}

// 5. 领域规则
func (m *Model) IsActive() bool {
    return m.Status == 0
}

func (m *Model) HasChildren(db *gorm.DB) (bool, error) {
    count, err := m.CountChildren(db, m.ID)
    return count > 0, err
}
```

### Service 层使用模板

```go
// 1. 创建操作（使用批量冲突检查）
func (s *service) Create(ctx context.Context, req *Request) error {
    // 一次查询检查所有冲突
    conflicts, err := (&model.Model{}).FindConflicts(s.db, req.Field1, req.Field2)
    if err != nil {
        return fmt.Errorf("检查冲突失败: %w", err)
    }
    
    // 在内存中进行多次校验
    for _, item := range conflicts {
        if item.Field1 == req.Field1 {
            return errors.New("字段1已存在")
        }
        if item.Field2 == req.Field2 {
            return errors.New("字段2已存在")
        }
    }
    
    // 创建实体
    entity := &model.Model{
        Field1: req.Field1,
        Field2: req.Field2,
    }
    
    // 调用模型层的创建方法
    if err := entity.Create(s.db, entity); err != nil {
        return fmt.Errorf("创建失败: %w", err)
    }
    
    return nil
}

// 2. 删除操作（使用领域规则）
func (s *service) Delete(ctx context.Context, id int64) error {
    // 检查实体是否存在
    entity, err := (&model.Model{}).FindByID(s.db, id)
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return errors.New("实体不存在")
        }
        return fmt.Errorf("查询失败: %w", err)
    }
    
    // 使用领域规则检查
    hasChildren, err := entity.HasChildren(s.db)
    if err != nil {
        return fmt.Errorf("检查子项失败: %w", err)
    }
    if hasChildren {
        return errors.New("存在子项，无法删除")
    }
    
    // 调用模型层的删除方法
    if err := entity.Delete(s.db, id); err != nil {
        return fmt.Errorf("删除失败: %w", err)
    }
    
    return nil
}
```

## 开发流程

### 新增业务模块

1. **定义 Model 结构**
```go
type Model struct {
    ID     int64
    Name   string
    Status int32
    // ...
}
```

2. **添加基础 CRUD 方法**
```go
func (m *Model) Create(db, model) error
func (m *Model) Update(db, id, updates) error
func (m *Model) Delete(db, id) error
func (m *Model) FindByID(db, id) (*Model, error)
```

3. **添加查询方法**
```go
func (m *Model) List(db, offset, limit, filters) ([]Model, int64, error)
func (m *Model) FindByXX(db, xx) (*Model, error)
```

4. **添加冲突检查方法（性能优化关键）**
```go
func (m *Model) FindConflicts(db, field1, field2) ([]Model, error)
func (m *Model) CheckXXExists(db, xx) (bool, error)
```

5. **添加领域规则**
```go
func (m *Model) IsActive() bool
func (m *Model) CanXX() bool
```

6. **Service 层调用**
```go
// 使用 Model 方法组合业务逻辑
conflicts, _ := (&model.Model{}).FindConflicts(...)
entity, _ := (&model.Model{}).FindByID(...)
```

## 性能优化检查清单

### ✅ 必须优化

- [ ] 创建时的唯一性检查（多字段）
- [ ] 更新时的唯一性检查（多字段）
- [ ] 高频查询操作
- [ ] 批量操作

### ⚠️ 可选优化

- [ ] 低频查询操作
- [ ] 一次性查询
- [ ] 简单的单字段检查

## 常见问题

### Q1: 什么时候应该封装到 Model 层？

**A:** 
- ✅ 基础 CRUD 操作
- ✅ 简单查询（FindByXX）
- ✅ 统计方法（Count、Has）
- ✅ 领域规则（IsActive）
- ✅ 批量查询优化（FindConflicts）

### Q2: 什么时候应该保留在 Service 层？

**A:**
- ✅ 业务编排
- ✅ 跨聚合事务
- ✅ 外部服务调用
- ✅ 复杂业务规则

### Q3: 如何优化多字段唯一性检查？

**A:** 使用批量查询 + 内存校验
```go
// ❌ 不好：3次查询
CheckField1Exists()
CheckField2Exists()
CheckField3Exists()

// ✅ 好：1次查询
conflicts := FindConflicts(field1, field2, field3)
// 内存中校验
```

### Q4: Model 方法应该返回什么？

**A:**
- 查询方法：返回实体或实体列表
- CRUD 方法：返回 error
- 统计方法：返回 int64 + error
- 领域规则：返回 bool

### Q5: 如何处理复杂查询？

**A:**
- 简单查询：封装到 Model 层
- 复杂跨表查询：保留在 Service 层
- 可复用的复杂查询：考虑 Repository 层

## 代码审查要点

### Model 层

- [ ] 方法命名清晰（FindByXX、CheckXX、CountXX）
- [ ] 返回值类型正确
- [ ] 错误处理完整
- [ ] 没有业务判断逻辑
- [ ] 没有外部服务调用

### Service 层

- [ ] 使用 Model 方法而不是直接操作数据库
- [ ] 批量查询优化已实现
- [ ] 业务逻辑清晰
- [ ] 错误处理完整
- [ ] 日志记录完整

## 示例对比

### 优化前
```go
// Service 层直接操作数据库
func (s *service) Create(req) error {
    var count int64
    s.db.Model(&Model{}).Where("name = ?", req.Name).Count(&count)
    if count > 0 {
        return errors.New("名称已存在")
    }
    
    s.db.Model(&Model{}).Where("code = ?", req.Code).Count(&count)
    if count > 0 {
        return errors.New("编码已存在")
    }
    
    model := &Model{Name: req.Name, Code: req.Code}
    return s.db.Create(model).Error
}
```

### 优化后
```go
// Model 层提供能力
func (m *Model) FindConflicts(db, name, code) ([]Model, error) {
    // 一次查询返回所有冲突
}

// Service 层组合能力
func (s *service) Create(req) error {
    conflicts, _ := (&Model{}).FindConflicts(s.db, req.Name, req.Code)
    
    for _, item := range conflicts {
        if item.Name == req.Name {
            return errors.New("名称已存在")
        }
        if item.Code == req.Code {
            return errors.New("编码已存在")
        }
    }
    
    model := &Model{Name: req.Name, Code: req.Code}
    return model.Create(s.db, model)
}
```

## 总结

充血模型的核心是：
1. **Model 提供能力**：基础操作、查询、统计、领域规则
2. **Service 组合能力**：业务编排、性能优化、复杂规则
3. **性能优先**：批量查询、一次查询多次校验
4. **职责清晰**：Model 不做业务判断，Service 不直接操作数据库
